\documentclass[twosided]{report}

% Packages %
\usepackage{fancyhdr}
\usepackage{titling}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{framed}
\usepackage{enumerate}
\usepackage[hidelinks]{hyperref}
\usepackage{soul}
\usepackage{pbox}

\hypersetup{linktoc=all}

% Stylings %
\pagestyle{fancy}

% Commands %
\newcommand{\subtitle}[1]{%
  \posttitle{%
    \par\end{center}
    \begin{center}\large#1\end{center}
    \vskip0.5em}%
}

% Colors %
\definecolor{sblgrey}{RGB}{100, 100, 100}
\definecolor{sblbackground}{RGB}{241, 240, 236}
\definecolor{sblkeyword}{RGB}{255, 39, 103}
\definecolor{sbltext}{RGB}{7, 13, 13}
\definecolor{sblcomment}{RGB}{94, 109, 94}
\definecolor{sblstring}{RGB}{25, 46, 154}

% Footer/Header %
\fancyhead[LE,RO]{\slshape Chapter \thechapter}
\fancyhead[LO,RE]{\slshape \nouppercase\rightmark}
\fancyfoot[C]{\thepage}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\lstdefinestyle{fstar}{
	backgroundcolor=\color{sblbackground},
	tabsize=1,
	captionpos=b
  	belowcaptionskip=1\baselineskip,
  	breaklines=true,
  	frame=single,
	frameround=tttt,
	captionpos=b,
  	language=Caml,
	morekeywords={open, module, val, assert},
	showspaces=false,
  	showstringspaces=false,
	showtabs=false,
  	numbers=left,
  	numbersep=5pt,
  	numberstyle=\tiny\ttfamily\color{sblgrey},
	xleftmargin=\parindent,
  	basicstyle=\footnotesize\ttfamily\color{sbltext},
  	keywordstyle=\bfseries\color{sblkeyword},
	otherkeywords={=, :, |},
  	stringstyle=\color{sblstring},
	commentstyle=\color{sblcomment}
}

\lstdefinestyle{cxml}{
	backgroundcolor=\color{sblbackground},
	tabsize=1,
	captionpos=b
  	belowcaptionskip=1\baselineskip,
  	breaklines=true,
  	frame=single,
	frameround=tttt,
	captionpos=b,
  	language=xml,
	showspaces=false,
  	showstringspaces=false,
	showtabs=false,
  	numbers=left,
  	numbersep=5pt,
  	numberstyle=\tiny\ttfamily\color{sblgrey},
	xleftmargin=\parindent,
  	basicstyle=\footnotesize\ttfamily\color{sbltext},
  	keywordstyle=\bfseries\color{sblkeyword},
  	stringstyle=\color{sblstring},
	commentstyle=\color{sblcomment}
}

\begin{document}

\begin{titlepage}
\begin{center}

\includegraphics[scale=0.4]{images/ITULogo.jpg}\\[1cm]

\textsc{\LARGE IT University of Copenhagen}\\[1.5cm]

\textsc{\Large Bachelor Project}\\[0.5cm]


% Title
\HRule \\[0.4cm]
{\huge \bfseries Verifiable Secure Open Source Alternative to NemID}\\[0.1cm]
\HRule \\[1.5cm]

% Author and supervisor
\begin{minipage}[t]{0.45\textwidth}
\begin{flushleft} \large
\emph{Authors:}
\\[10pt]
Andreas Hallberg \textsc{Kjeldsen}\\
\emph{ahal@itu.dk}
\\[10pt]
Morten Chabert \textsc{Eskesen}\\
\emph{mche@itu.dk}\\
\end{flushleft}
\end{minipage}
\begin{minipage}[t]{0.45\textwidth}
\begin{flushright} \large
\emph{Supervisor:}
\\[10pt]
Dr. Joseph Roland \textsc{KINIRY}\\
\emph{josr@itu.dk}
\end{flushright}
\end{minipage}

\vfill

% Bottom of the page
{\large May 22, 2013}

\end{center}
\end{titlepage}


\begin{abstract}
Denmark currently has NemID to provide every resident of Denmark with a digital signature. The frontend of NemID is developed in Java, thereby forcing the danish residents to install Java. Java is not well supported on all mobile platforms, there have also been many security issues with Java lately. Java is therefore frowned upon as the technology selected for NemID. The objective of the report is to create a replacement for NemID that is both verifiable secure and open source. We propose the use of executable models to prove the security properties of such a system. We provided a detailed the description of the protocol which is based on the SAML Single Sign-On protocols. We use the programming language F* which is a value-dependent, typed language with refinement types to formalize the protocol. We have formalized key parts of the protocol thereby proving it possible to formalize such protocols as a whole with F*. Therefore we have shown that it is possible to use a language like F* to formally specify the protocol and have an executable model at the same time.
\end{abstract}

\renewcommand{\abstractname}{Acknowledgements}
\begin{abstract}
First of all we would like to thank Joseph Roland Kiniry for his interest in our work and for his many encouraging and helpful comments. Secondly we would also like to thank Hannes Mehnert for his help in designing the protocol and his insights. Lastly we would like to thank Jacob H{\o}jgaard for laying the groundwork in his masters thesis \emph{Securing Single Sign-On System With Executable Models}.
\end{abstract}

\begingroup
    \let\clearpage\relax
	\tableofcontents
    \listoffigures
	\lstlistoflistings
\endgroup

\chapter{Introduction}
\label{chap:intro}
\emph{Security through obscurity} is a principal within security engineering. It refers to the reliance on secrecy of the design or implementation of a system to provide security. Kerckhoffs's principle dictates that a cryptographic system where only the key is kept private should be secure even in the hands of the enemy.
\begin{quote}
\textit{"There is no security by obscurity"} - Auguste Kerckhoffs \cite{kerckhoffs}
\end{quote}

Based on this, it can be assumed that in the making of a secure system, obscurity should not be used for improving the security.
\begin{quote}
\textit{"A system is secure only when it is secure in the light of day, under full public view."} - Dr. Joseph Roland Kiniry \cite{ftspeech}
\end{quote}
\par
In Denmark it is required to use NemID when accessing public websites, online banks and other services requiring a digital signature (DanskeSpil e.g.). NemID claims to be a secure system, they state various reasons that would give the impression that they are right \cite{omnemidsikkerhed}. But looking at the system from the outside, there is no way of telling if their claim of a secure system is right or wrong.
\par
Even though there is no public record of the NemID system being completely compromised, there is no way for us outsiders to verify whether or not it could happen. This is due to NemID following the security through obscurity principal. The source code for their key components are not publicly available, the Java applet they are providing has been obfuscated and the API they have made available does not reveal enough to conclude anything.

\newpage
\section{Objectives}
In this project we set out to create a replacement for NemID that is both verifiable secure and also open source. For the sake of being able to reference this new system throughout the report, we will refer to it as \emph{OpenNemID}.
\\
\par
The goal of this project is to:
\begin{enumerate}
	\item Describe and outline the OpenNemID protocol, including but not limited to registration and login.
	\item Formalize the specification of OpenNemID in F* to the extent possible.
\end{enumerate}

\section{Scope}
This project has had its focus towards specifying a new protocol that could replace NemID. The intent of this project is therefore not to develop a complete system, but to make a formal specification for a system that could then later be used to engineer a new system.

\section{Background}
We are extending the work done by Jacob H{\o}jgaard in his Masters thesis \emph{'Securing Single Sign-On Systems With Executable Models'}. Jacob's research has focused on the current implementation of NemID and therefore describes, outlines and models the current system used in Denmark as of May 2013.
\par
NemID is a part of NemLog-in, which is owned by the Danish government through the Agency of Digitalization, henceforth \emph{DIGST}. NemLog-in is a key component in the ambitious digitalization strategy outlined by the DIGST \cite{digst}. The digitalization strategy specifies that all interaction between residents and any public institution should be possible online from 2015. A public login federation\footnote{Login federation refers to the concept of federated identity where a user can link identities stored in different identity management systems. The term \emph{Federation} refers to a union of selfgoverning states, which is very applicable for this term \cite{jacob}.}, NemLog-in, is used for this purpose.
\par
Nets DanID\footnote{Nets DanID A/S is a company within the Nets group, which is owned by the danish national bank and a number of danish banks}, has developed NemID. Their contract runs from august 21st 2008 to august 20th 2015, though the contract can be extended twice, each time by a one year period \cite{nemidcontract}. When the current contract expires it is possible that a new contract mandating a replacement for NemID could be established.
\par
NemID has received quite a lot of criticism because it uses Java as the frontend for its users.  Java is cross-platform (Windows, OS X, Unix etc.) and can be embedded directly onto webpages. A reason for choosing Java for NemID, could be  its cross-platform capabilities, but it is more likely that is was the cryptographic features (applet signing e.g.) that made the difference. Unfortunately Java is one of the most frequently exploited pieces of software \cite{kaspersky}, which in turn means that to use NemID, the user would have to install software that later could result in the user's computer being compromised. Furthermore, most mobile platforms has no support for Java, thereby rendering it impossible to use NemID on a mobile device.
\par
From an academic point of view it would be interesting to see if a platform independent replacement for NemID can be made by students within a very limited timeframe, that does not rely on hidden and obfuscated code, but on open source and verification tools to prove the system secure.


\chapter{Technical background}
\label{chap:techbg}
This chapter will clarify the technical concepts that has been used in this report. It will describe the SAML protocol and the Danish specialization OIOSAML. Furthermore it will describe the concept of static analysis and outline different protocol verification tools and our choice of tool. Lastly it will introduce the concept \emph{n-factor authentication} that has been used in the development of this project.

\section{SAML protocol}
The Security Assertion Markup Language or SAML is an XML based language created for the exchanging of authentication and authorization (security tokens) between different systems or domains, in particular between a service provider and an identity provider. The latest version of SAML is 2.0 released in 2005. SAML specifies three roles: \emph{principal}, \emph{identity provider} and \emph{service provider}. Principal refers to an entity that can be authenticated, therefore both the user and the identity provider and service provider are principals. SAML addresses the problem of web browser single-sign on (SSO). SSO means that the user only has to login once per identity provider per session. Practically this means that the user only has to be redirected once to the identity provider for authentication per session. The identity provider creates a session for the user that can be reused for any subsequent authentication request. SAML specifies 5 core elements - \emph{Assertions}, \emph{Protocols}, \emph{Bindings}, \emph{Profiles} and \emph{Metadata}. See appendix A for examples of assertion and SAML messages.
\par
\emph{Assertions} are security tokens containing statements or claims about a principal. These statements in SAML are called attributes and they usually hold information like name, last name, email etc. The principal is referred to as the \emph{subject} in an assertion.

\begin{figure}[H]
	\centering
	\begin{tabular}{r l}
	    \parbox[t][][t]{2.8cm}{\hfill $Assertion :=$} &
	    \parbox[t][][t]{6.4cm}{
			$[Id : String\\
			IssueInstant : DateTime\\
			Issuer : String\\
			Signature : String\\
			Subject : Subject\\
			Conditions : Conditions\\
			AttributeStatement : List<attribute>\\
			AuthnStatement : AuthnStatement]$} \\
	\end{tabular}
	\\[0.2cm]
	\begin{tabular}{r l}
	    \parbox[t][][t]{2.8cm}{\hfill $Subject :=$} &
	    \parbox[t][][t]{6.4cm}{
			$[NameId : String\\
			InResponseTo : String\\
			NotOnOrAfter : DateTime\\
			Recipient : String]$} \\
	\end{tabular}
	\\[0.2cm]
	\begin{tabular}{r l}
	    \parbox[t][][t]{2.8cm}{\hfill $Conditions :=$} &
	    \parbox[t][][t]{6.4cm}{
			$[NotBefore : DateTime\\
			NotOnOrAfter : DateTime\\
			AudienceRestriction : List<String>]$} \\
	\end{tabular}
	\\[0.2cm]
	\begin{tabular}{r l}
	    \parbox[t][][t]{3.4cm}{\hfill $AuthnStatement :=$} &
	    \parbox[t][][t]{7cm}{
			 $[AuthnInstant : DateTime\\
			 SessionIndex : String]$} \\
	\end{tabular}
	\caption{The elements in a SAML Assertion}
\end{figure}

\par

\emph{Protocols} describe the messages that can be exchanged between the service provider and the identity provider when exchanging assertions. The protocol used in OpenNemID is called the Authentication Request Protocol. This protocol consists of a \emph{AuthnRequest} message and a response message. The AuthnRequest message has an id that must be unique and the creator of the message is responsible for ensuring it is.
AuthnRequest has 5 fields:
\begin{enumerate}
	\item The \emph{Id} - unique identifier for the message.
	\item \emph{IssueInstant} - timestamp of when the message was issued.
	\item The \emph{Destination} - the receiver of the request.
	\item \emph{Issuer} - the initiator of the authentication.
	\item \emph{Conditions} - conditions of the request (audience restriction, not before this time or not after this time).
\end{enumerate}

\begin{figure}[H]
	\centering
	\begin{tabular}{r l}
	    \parbox[t][][t]{2.4cm}{\raggedleft $AuthnRequest :=$} &
	    \parbox[t][][t]{4.2cm}{
			$[Id : String\\
			IssueInstant : DateTime\\
			Destination : URI\\
			Issuer : String\\
			Conditions : Conditions]$} \\
	\end{tabular}
	\caption{The SAML AuthnRequest message}
\end{figure}

\par
The response message has fields \emph{Id} and \emph{IssueInstant} that was specified in the request message. The \emph{Destination} is the endpoint address for the service provider. The \emph{Issuer} is the entity Id of the identity provider. The response message also has a field \emph{inResponseTo} that specifies the id of the AuthnRequest the response is to. The \emph{Status} field can only have one of three possible values - \emph{Requester}, \emph{Responder} or \emph{Success}. The \emph{Assertion} can only be issued if the \emph{Status} field is \emph{Success}. The assertion can either be plain text or an \emph{EncryptedAssertion} which will be encrypted under the public key of the recipient of the message (service provider).

\begin{figure}[H]
	\centering
	\begin{tabular}{r l}
	    \parbox[t][][t]{1.5cm}{\raggedleft $Reponse :=$} &
	    \parbox[t][][t]{4.2cm}{
			$[Id : String\\
			IssueInstant : DateTime\\
			Destination : URI\\
			InResponseTo : String\\
			Issuer : String\\
			Status : String\\
			Assertion : Assertion]$} \\
	\end{tabular}
	\caption{The SAML Response message}
\end{figure}

\par
\emph{Bindings} specifies how the messages are mapped to the underlying HTTP(S) or SOAP protocols. However in this report only HTTP POST and HTTP REDIRECT bindings will be addressed. The POST binding maps the content of messages to hidden XHTML form fields that are named SAMLRequest and SAMLResponse. The content is BASE64 encoded. For the REDIRECT binding the message content is mapped to the URL query string with SAMLRequest and SAMLResponse as the identifier. Since the URL query string has limited capacity the message is compressed by the DEFLATE algorithm and after that it is BASE64 encoded and URL encoded.
\par
\emph{Profiles} specifies how the \emph{assertion}, \emph{protocol} and \emph{binding} are used to fulfill a specific requirement or a use case. The Danish specialization of the SAML Web Browser SSO Profile, OIOSAML, will be described in further detail in section 2.1.1.
\par
\emph{Metadata} is the necessary data exchanged between the involved parties in order to know each other. A service providers metadata contains the certificate for signing messages and a message that the identity provider should use for encrypting assertion. It also contains endpoints which specifies the addresses to which the identity provider should send response messages. There can be more than one endpoint if different bindings are available. The identity providers metadata also contains signing and encryption certificates and endpoints that specify the addresses for sending requests to the identity provider. There can be more endpoints for different bindings. The identity provider will publish the attributes it is able to serve through its metadata.

\subsection{OIOSAML}
The Danish specialization OIOSAML, \emph{OIO Web SSO Profile}, is a dialect of the SAML profile \emph{Web Browser SSO}. This profile is a standard that specifies the interactions between a user and the government and/or other public institutions.
\par
OIOSAML has specific requirements for binding and protocol. The point of adding these measures is to secure the protocol further and that some of the extensibility of the SAML Web Browser SSO is not necessary. An example is that in plain SAML it is possible to issue authentication requests without having a prior exchange of metadata. This is not desirable in OpenNemID since the security of the protocol will be improved by adding a controlled connection flow, where the service providers are approved beforehand. In the following there has been some concepts left out if deemed insignificant to the level of description necessary for this report.\\\\
\textbf{OIOSAML mandates for the Service Provider}
\begin{itemize}
  \item The metadata of the service provider should be known to the identity provider (as mentioned before there must be a formal exchange of metadata between the parties).
  \item Binding for AuthnRequest should be HTTP REDIRECT with the message DEFLATE encoded.
  \item Transport should be over (one-way) SSL/TLS.
  \item The \emph{AuthnRequest} must be signed and the signature placed as a query parameter identified as "Signature".
  \item The RelayState\footnote{RelayState is a mechanism that the service providers can use to associate any subsequent profile messages with the original request (could be the protected resource requested by the user)} must be opaque.
\end{itemize}
\textbf{OIOSAML mandates for the Identity Provider}
\begin{itemize}
  \item The metadata of the service provider should be known to the identity provider (as mentioned before there must be a formal exchange of metadata between the parties).
  \item If the response is an error response the identity provider must not include any assertions.
  \item Successful responses can contain only one assertion.
  \item The assertions must state the level of authentication achieved\footnote{Authentication level refers to the level of authentication achieved by the subject on a scale from 1-5 where 5 is highest.}.
  \item Response messages should be sent to the service provider using the HTTP POST binding
  \item Transport should be over (one-way) SSL/TLS
  \item Response messages should not be signed but instead the embedded Assertion should be signed and encrypted
\end{itemize}
\textbf{OIOSAML mandates for assertions}
\begin{itemize}
  \item Assertions must contain only one AuthnStatement and one AttributeStatement
  \item The assertion must be encrypted with the certificate received from the service provider through the exchanged metadata
  \item The issuer field which is the entity Id of the identity provider must be included in the assertion
  \item The assertion must be signed with the certificate described in the metadata exchanged with the service provider
\end{itemize}
\section{Static analysis}
Static program analysis is the opposite of dynamic analysis which is analysis performed on executing programs. Therefore static analysis is analysis of computer software that is performed without actually executing programs. Static analysis is usually the analysis performed by an automated tool. There exists tools to perform analysis on the behavior of individual statements and declarations and tools to perform analysis of the complete source code of a program. Static analysis has been successfully used to automatically validate security properties of classical protocols. The technique has been used to validate the SAML Single Sign-On protocols \cite{HansenSkriver}.

\section{Protocol verification tools}
A communication protocol is a system of digital message formats and rules for exchanging those messages in or between computing systems. A cryptographic protocol or security protocol is an abstract or concrete communications protocol that performs a security-related function and applies cryptographic models. Cryptographic protocols can be verified formally on an abstract level. Formal verification is an attempt at proving or disproving the correctness of intended algorithms underlying a system with regards to a certain formal specification. There exists various tools to formally verify a cryptographic protocol on an abstract level. This section will outline the tools we have investigated through the work of this project and the key features of these tools.

\subsection{ProVerif}
ProVerif is an automatic cryptographic protocol verifier in the Dolev \& Yao model\footnote{Cryptographic primitives are assumed perfect and cyphers cannot be decrypted without the proper decryption key}. It is based on a representation of the protocol by Horn clauses\footnote{Horn clause is a clause (a disjunction of literals) with at most one positive literal}. One of ProVerif's key features is its ability to handle many different cryptographic primitives, including shared- and public-key cryptographys, hash functions and Diffie-Hellman key agreements\footnote{Diffie-Hellman keyexchange is a specific method for the exchanging of cryptographic keys}. The other key feature is its ability to handle an unbounded number of sessions of the protocol (even in parallel). ProVerif can prove secrecy\footnote{The adversary cannot obtain the secret}, authentication, strong secrecy\footnote{The adversary does not see the difference when the value of the secret changes} and equivalences between processes that differ only by terms.

\subsection{F*}
\label{sect:techbgfstar}
F* is a new research language from Microsoft Research. The language is dependently typed for secure distributed programming. F*'s purpose is the enabling of the construction and communication of proofs of program properties and secondly of properties of a programs environment in a verifiable secure way. F* is based on the functional programming language F\# and compiles to .NET bytecode in a type preserving style. Even though F* is a formal specification language it is still executable. Furthermore F* has a fully abstract compiler from F* to JavaScript. The current version of the F* compiler is considered to be an $\alpha$-release.

\subsection{JSCert}
JSCert is an ongoing project. JSCert is short for Certified JavaScript. The goal of the project is to really understand JavaScript. The project is building models of ECMAScript\footnote{ECMAScript is a scripting language often used for client-side scripting on the web} semantics in the Coq proof assistant and automated logical reasoning tools built on those semantics. The project introduces a program logic for reasoning about a broad subset of JavaScript. They have proved a strong soundness result. The libraries written in their subset and proved correct with respect to their specifications will be well-behaved - even when called by arbitrary JavaScript code.


\subsection{XOR-ProVerif}
XOR-ProVerif is a tool for analyzing protocols with XOR. It is a tool with an implementation of the reduction of the derivation problem for Horn theories with XOR to the XOR-free case in combination with ProVerif. These theories allow the modeling of a large class of intruders capabilities and protocols that employ the XOR operator.

\subsection{DH-ProVerif}
DH-ProVerif is a tool for analyzing protocols with the Diffie-Hellman exponentiation. The tool is an adaption of the XOR-ProVerif approach to the case of Diffie-Hellman exponentiation. The approach is to reduce the derivation problem for Horn theories modulo algebraic properties of Diffie-Hellman exponentiation to a purely syntactical derivation problem for Horn theories. The reduction for Diffie-Hellman exponentiation is more efficient than the one for XOR.

\subsection{CSProto}
CSProto is a tool for analyzing contract signing protocols. The tool is used to prove that certain game-theoretic security properties, including balance for contract signing protocols, can be decided in a Dolev \& Yao style model with a bounded number of sessions. The decision algorithm is based on constraint-solving procedures which have been successfully employed in tools for reachability properties.

\subsection{Our choice}
We have chosen to formally specify OpenNemID using F* for several reasons. We both have previous experience working with the functional programming language F\# which F* is based on and a little experience with ML. However the most contributing factors was:
\begin{enumerate}
\item Since we are extending the work done by Jacob it made sense to use F* as he did.
\item The fully abstract compilation from F* to JavaScript.
\item F* is executable.
\end{enumerate}

\section{N-factor authentication}
\label{sect:nfactauth}
Two-factor authentication is the process of a requesting entity presenting some evidence of its identity to a second entity. The goal of two-factor authentication is to decrease the possibility that the requester is presenting false evidence of its identity. In a login scenario the requester would be a user requesting to login. Two-factor authentication requires the use of two of three authentication factors:
\begin{enumerate}
\item Something the requester knows (e.g. password)
\item Something the requester has (e.g. mobile phone)
\item Something the requester is (e.g. biometric characteristic - such as fingerprint)
\end{enumerate}
\par
NemID currently implements two-factor authentication. It uses the first factor which is the user's userid and password. It also uses the second factor which is the physical cardboard keycard that comes with creating a NemID login. This cardboard keycard comes with numeric challenges and their corresponding numeric keys. So when a user logs in with their userid and password they will be prompted for the numeric key corresponding to the numeric challenge displayed in the Java applet.
\par
The OpenNemID protocol extends the two-factor authentication to \emph{n-factor authentication}, thereby adding multiple layers of security that would make it harder for an adversary to login. The first authentication is the first factor - userid and password. After this there are various ways for a user to authenticate themselves further based on their registration. However it will only use either the first or second factor. Even though it would be preferable with a biometric characteristic authentication factor for digital identities, this is at the moment not doable. The OpenNemID protocol requires that a user at least has the standard first factor (a userid and a password) and at least one more authentication method. The user will by default have to authenticate themselves through all the authentication methods they have added.
\\
\\
The authentication methods that have been considered are:
\begin{enumerate}
	\item[] \textbf{OpenID}\\
		OpenID is an open standard federated login utilizing co-operating sites (or relying parties) for user authentication. OpenID is not limited to a single institution providing the identity of the users, instead there can be multiple providers, some of the major ones are Google, Yahoo, VeriSign and Wordpress \cite{openid}. To use OpenID the users would be required to create and setup an account with one of the providers.\\
		Some of the providers might have introduced extra security step, one such provider is Google. Google has its own security implementations, such as two-factor authentication. As OpenNemID would depend on the user fully authenticating with OpenID, the user would also have to pass Googles two-factor authentication in the case of authorizing at Google.
	\item[] \textbf{Facebook Connect}\\
		Facebook Connect is the single sign-on solution provided by Facebook. This would require the user to create and setup a Facebook account. 
	\item[] \textbf{One-Time Passwords}\\
		A One-Time Password, henceforth \emph{OTP}, is a generated password with the limitation of only being usable once. To further enhance the security of the OTP, a time limiting factor could be applied, thereby creating a Time-based One-time Password, henceforth \emph{TOTP}.\\
		A TOTP is generated based on a uniform algorithm, the requirements for the algorithm includes that the key must be shared by the prover and the verifier, the time-step value\footnote{The time-step value is the amount of seconds that must be between each generated password. If the first password was generated at 01:03:02 PM and the time-step value was 30, the next password must be generated at 01:03:32 PM.} must be the same for the prover and the verifier, both the prover and the verifier must have the capabilities of deriving the current Unix timestamp\footnote{Unix time, or POSIX time, refers to the amount of seconds that has passed since January 1st 1970 00:00:00 UTC, without counting leap seconds.} \cite{rfc6238}.\\
		Various client applications have been developed for generating the TOTP. \emph{Google Authenticator} is Google's open-source TOTP client that runs on mobile platforms such as Android, iOS and Blackberry.
	\item[] \textbf{Yubico}
		Yubico has specialized in OTP hardware and software. Their flagship product, the \emph{YubiKey}, is a tiny device that is inserted into the USB port on the user's device. When challenged with a OTP, the user would use the YubiKey to generate the OTP. YubiKey is already integrated with various single-sign on systems such as OpenID.
	\item[] \textbf{SMS}\\
		A OTP could be generated and send to the user's mobile phone.
	\item[] \textbf{Knowledge-based Authentication}\\
		Knowledge-based authentication can either by static or dynamic.\\
		Static knowledge-based authentication refers to predefined questions and answers, this could be a question such as "What is your mother's maiden name" and the user would have input the proper answer beforehand. For our implementation it is not specified whether or not the questions should be predefined by the authentication provider or if the user should be able to create them.\\
		Dynamic knowledge-based authentication refers to questions being generated on the fly based on data stored related to the user, this could be questions like "What street did you live on at your previous residence?". 
\end{enumerate}

%%%%%%%%%% CHAPTER %%%%%%%%%%
\chapter{Modelling the protocol}
\label{chap:modelspecify}
Before formalizing the protocol, it's required to specify and explain some of the words, concepts and meanings used within the protocol. This will be done by using graphical representations of the message flow.

\section{A protocol walkthrough}
A sequence diagram depicting the protocol is useful for introducing the basics of the protocol. The sequence diagrams give a brief overview of the logon protocol, identity provider registration protocol and the user registration protocol. The logon protocol will, later in this chapter, be modeled using a communication diagram, this is done to give a more thorough descriptions

\subsection{Logon protocol}
Jacob has depicted the NemID protocol with 12 steps. The sequence diagram shows how the browser must delegate messages from the service provider to the identity provider, while also having to delegate messages from DanId to the identity provider. A single challenge is used to authenticate the user after credentials have been submitted.

\begin{figure}[H]
	\centering
	\includegraphics{images/Sequence-login-Jacob.jpg}
	\caption[Sequence diagram of authentication with NemID]{Sequence diagram of authentication with NemID \cite{jacob}}
\end{figure}

In comparison to NemID, the OpenNemID protocol have modified the way messages are sent. The amount of messages the browser must delegate has been limited to a few. There is not just one challenge used to authenticate the user, there are n challenges, as described in section \ref{sect:nfactauth}. The amount of steps in the protocol have been reduced to 8.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.4]{images/Open-NemId-(User-Login).png}
	\caption{Sequence diagram of authentication with OpenNemID}
\end{figure}

\subsection{Identity provider registration protocol}
An identity provider has to register with an authentication provider to establish a trusted relationship and an agreement that the authentication provider will in fact act as a provider for authenticating users. A challenge will be send to the identity provider to confirm that the identity provider is who they claim to be.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.6]{images/Open-NemId-(IdentityProvider-Registration).png}
	\caption{Sequence diagram of identity provider registration with OpenNemID}
\end{figure}

\subsection{User registration protocol}
Before a user is able to authenticate at the authentication provider, they have to register there first. The user has to activate their account using credentials received via mail. Upon activation, a new password must be chosen, optionally a userid can also be chosen. The user must be able to add and revoke n-factor challenges while also being able to revoke previously granted identity provider permissions.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.6]{images/Open-NemId-(User-Registration).png}
	\caption{Sequence diagram of user registration with OpenNemID}
\end{figure}

\section{Protocol prerequisites}
It's important to have some requirements as to how the systems should function. The requirements helps define certain properties the involved participants must have or obey to.

\subsection{Shared}
The NemLog-in specification mandates the use of OIOSAML, this will most likely not be excluded, therefore we assume that OpenNemID also has to use it. Further OIOSAML mandates the use of one-way SSL/TLS for all bindings, the mandate does not specify a specific version, though it can be assumed that a minimum version of SSL 3.0 due to the fact that SSL 2.0 is in general considered deprecated. We assume the use of SSL 3.0 or TLS 1.0 in this report.
\par
As mentioned before, SAML uses the browser to transfer messages from one principal to the other. The way to do this is through HTTP REDIRECTs, which could be either a HTTP-GET REDIRECT or a HTTP-POST REDIRECT. The HTTP protocol accepts a Location head in the HTTP RESPONSE which indicates where the browser should redirect to. The location header redirect will act as a HTTP-GET REQUEST which excludes the usage of POST data, thereby limiting the amount of data that can be transferred. To overcome this problem HTTP-POST REDIRECTs are used, these are not a part of the HTTP protocol, but is synthesized by using JavaScript to emulate a regular HTTP-POST REQUEST. Therefore it is required for the user's browser to follow redirects and to have JavaScript enabled.
\par
For there to be any actual messages to flow between the service provider and the identity provider, it is assumed that they reside in different domains and are different entities.
\par
The identity provider is only to issue assertions to known service providers, this requires that SAML metadata has been exchanged beforehand. The certificates used for signing and encrypting has to be checked for revocation and validity whenever used.
\\
\par
\textbf{To summarize:}
\begin{enumerate}
	\item OIOSAML mandates the use of SSL(3.0)/TLS(1.0).
	\item The browser must follow redirects.
	\item The browser must have JavaScript enabled.
	\item Service provider and identity provider are different entities residing in different domains.
	\item SAML metadata must have been exchanged between the service provider and identity provider.
	\item Signature check and encryption requires validity/revocation check of the certificate.
\end{enumerate}

\subsection{NemID specifics}
It's required for the OCES certificates used for signing and encrypting to have been issued by DanID.

\subsection{OpenNemID specifics}
For the communication between the authentication provider and the identity provider, a secure tunnel must have been set up. Further the user must have registered at the authentication provider.
\par
We have assume the availability of a web cryptography API in this report. A web cryptography API has not yet been standardized, but a standardization is being worked on. A draft is available \cite{webcrypto}. 

\section{Formalizing protocol messages}
The UML communication diagrams depicting the protocols are made up of two or more participants, henceforth principals, and the messages flowing through the system. The line between two principals indicates a channel where communication can flow. This channel is assumed to be a secure channel, meaning for HTTP messages, the HTTPS protocol would be used. An arrow indicates the direction of the message and the text on top of the arrow is the message being sent. The messages does not conform to any specific formalism, but follows a simple syntax. Messages are, very applicable, named in accordance with their HTTP protocol verb. The messages are to be interpreted the following way:
\begin{enumerate}
	\item[] \textbf{GET} means a HTTP-GET request. The parameter is the resource being requested.
	\item[] \textbf{POST} means a HTTP-POST request. The parameters are the destination for the request followed by the data being submitted.
	\item[] \textbf{REDIRECT} means either a HTTP-REDIRECT or a JavaScript redirect, whichever is used is not important for the purpose of the description. The parameters are the destination for the redirect followed by the parameters to include in the redirect.
	\item[] \textbf{RESPONSE} means a HTTP-RESPONSE messages. The parameters are either the data included in the response or a HTTP status code indicating the type of the response along with a message, this is used for indicating when an error happen.
	\item[] \textbf{DELEGATE} means forwarding the data from the previous request. The parameters are the parameters from the previous request that were to be delegated.
	\item[] \textbf{AUTHENTICATE} is to be interpreted as the sequence of actions required to be authenticated at the specified NFactorChallenge. The AUTHENTICATE message is defined this generically on purpose because the way a user would authenticate for a NFactorChallenge can vary a lot depending on the challenge (see Section \ref{sect:nfactauth}).
\end{enumerate}

\section{Communication model}
\label{sect:communicationmodal}
To make the changes from NemID to OpenNemID clear, we will first show the communication diagram for NemID. Afterwards we will show the communication diagram for OpenNemID. Both diagrams make use of abbreviations. These abbreviations are listed at the top of the diagram along the word or phrase they abbreviate. We have tried to comply with Jacob's data as much as possible, due to the fact that his report conforms to the requirements mandated by DIGST.

\subsection{Message processing}
Information regarding the processing of messages have not been included in the diagrams. This is to prevent cluttering of the diagrams. To circumvent this, the processing rules will be described afterwards. The descriptions will be linked to a specific process number, meaning Process 3 would be the handling and response of message 3 in the diagram. Messages that are self-explanatory will not be further described.

\subsection{Communication diagram for NemID}
Description of the message processing for this diagram has been left out of our report, they can however be found in Jacob H{\o}jgaards report \cite{jacob}.

\begin{figure}[H]
	\centering
	\includegraphics{images/Communication-Jacob.jpg}
	\caption[Communication diagram for the complete NemID protocol]{Communication diagram for the complete NemID protocol \cite{jacob}}
	\label{fig:jacobCommunication}
\end{figure}

\subsection{Communication diagram for OpenNemID}
In this diagram, we have chosen to leave out the additional request to another service provider than the one initially used, this is due to the communication flow being exactly the same as in Jacobs diagram, see Figure \ref{fig:jacobCommunication}, message 13 to 18.
\par
In the communication diagram for OpenNemID, DanID has been replaced by AuthenticationProvider, for the sake of our protocol it is of no greater importance which company handles the authentication.
\par
We have strived to minimize the amount of messages flowing through the system to limit the amount of possible attack points for a potential adversary. We have also eliminated the need for transporting sensitive data, such as the users login data, from the authentication provider to the identity provider. This is done by mandating that the identity provider and the authentication provider exchange information using a secure tunnel without the user being able to interfere.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.6]{images/Communication.png}
	\caption{Communication diagram for the OpenNemID protocol}
	\label{fig:ourCommunication}
\end{figure}

\subsubsection{Message descriptions}
Process 1 describes the creation of the \emph{AuthnRequest} at the service provider when a resource has been requested. If the requested resource is not found a 400 Bad-Request message is returned. The use of url encoding (UrlEnc) and base64 encoding (Base64Enc) is to ensure that the data can be transferred as parameters in the URL.
\par
SAML and OIOSAML has a substantial amount of processing rules that dictates the processing of messages - disobeying these will cause an error. For the sake of communication the descriptions have been kept to a minimum, not listing all scenarios that would cause an error.

\begin{algorithm}[H]
	\caption{Process 1}
	\begin{algorithmic}
	\REQUIRE{GET is well-formed \AND IdP.Public \AND SP.Private}
	\IF{R exists}
		\STATE AR $\leftarrow$ CreateAuthnRequest()
		\STATE SAR $\leftarrow$ SIGN(AR, SP.Private)
		\STATE MA $\leftarrow$ UrlEnc(Base64Enc(DeflateCompress(AR)))
		\STATE RS $\leftarrow$ UrlEnc(Base64Enc(R))
		\RETURN REDIRECT(IdP, MA, SAR, RS)
	\ELSE
		\RETURN RESPONSE(400, Bad−Request)
	\ENDIF
	\end{algorithmic}
\end{algorithm}

Process 3 describes the handling of a AuthnRequest at the identity provider. The request will be handled in one of two ways depending on whether the AuthnRequest could be verified. In the case of verification failing, a SAML response will be returned indicating an error. Otherwise a page for requesting the users credentials is returned. The page returned will also contain the signed JavaScript for handling the OpenNemID specific actions. The JavaScript is signed using a certificate, \emph{IdPJsCert}, this certificate has to have been issued by the authentication provider.
\par
A challenge (nonce) is generated, this is to prevent an attack where an adversary would submit an identical request to one that has already been submitted, also known as a \emph{replay attack}. If the challenge was not introduced the second identical request could possibly be accepted as well.
\par
A cookie is created containing the AuthnRequest, signed AuthnRequest along with the relay state. This is done to free the identity provider from having to store the data, thereby granting more statelessness.
\begin{algorithm}[H]
	\caption{Process 3}
	\begin{algorithmic}
		\REQUIRE{GET is well-formed \AND IdP.Private \AND SP.Public \AND IdPJsCert.Public \AND IdP has JavaScript from AuthP}
		\STATE AR $\leftarrow$ DeflateDecompress(Base64Dec(UrlDec(MA)))
		\IF{VERIFY(AR, SAR, SP.Public)}
			\STATE C1 $\leftarrow$ GenChallenge()
			\STATE JS $\leftarrow$ GetStoredJavaScript()
			\STATE JS.SigParams.Challenge $\leftarrow$ C1
			\STATE JS.SigParams.Certificate $\leftarrow$ IdPJsCert.Public
			\STATE JS.SigParams.Signature $\leftarrow$ SIGN(JS.SigParams, IdPJsCert.Private)
			\STATE ARC $\leftarrow$ CreateCookie(MA, SAR, RS)
			\RETURN RESPONSE(JS, ARC)
		\ELSE
			\STATE RE $\leftarrow$ CreateResponse()
			\STATE RE.InResponseTo $\leftarrow$ AR
			\STATE RE.Status $\leftarrow$ ”Requester”
			\STATE MRE $\leftarrow$ Base64Enc(RE)
			\RETURN REDIRECT(SP, MRE, RS)
		\ENDIF
	\end{algorithmic}
\end{algorithm}

As specified in the formalization, it is required for the browser to allow JavaScript. The username, \emph{U} and password, \emph{P} for the user is not stored and fetched directly, but will be input by the user manually. Although for the description of process 4 it will be assumed that they are both ready right away. Before the user is prompted for username and password, the JavaScript is verified. The challenge is submitted together with the username and password. Hashing of the username and password has been omitted as it holds no functional enhancement towards the protocol.
\begin{algorithm}[H]
	\caption{Process 4}
	\begin{algorithmic}
		\REQUIRE{U \AND P \AND Browser allows JavaScript}
		\STATE SigParams $\leftarrow$ Js.SigParams
		\IF{VERIFY(SigParams, SigParams.Signature, SigParams.Certificate)}
			\STATE C1 $\leftarrow$ SigParams.Challenge
			\RETURN POST(U, P, C1)
		\ELSE
			\PRINT ERROR
		\ENDIF
	\end{algorithmic}
\end{algorithm}

In process 5 the identity provider confirms that the challenge received matches a previously issued challenge, and that is has not already been used. A SAML response indicating an error is returned if the challenge is not accepted, otherwise the username and password will be delegated to the authentication provider.
\begin{algorithm}[H]
	\caption{Process 5}
	\begin{algorithmic}
		\REQUIRE{POST is well formed}
		\IF{C1 matches challenge issued by IdP \AND C1 is valid}
			\STATE \textbf{Delegate} U \AND P \TO AuthP
		\ELSE
			\RETURN RESPONSE(ERROR)
		\ENDIF
	\end{algorithmic}
\end{algorithm}

Process 5.1 describes how the username and password submitted is used to identify a user at the authentication provider. If a user is found and is valid, a challenge will be generated and the next n-factor challenge for the user will be fetched. The n-factor challenge is signed and then returned. Were no valid user found based on the supplied username and password, a SAML response message indicating an error will be returned.
\begin{algorithm}[H]
	\caption{Process 5.1}
	\begin{algorithmic}
		\STATE USER $\leftarrow$ GetUser(U, P)
		\IF{USER is valid}
			\STATE C2 $\leftarrow$ GenChallenge()
			\STATE NF $\leftarrow$ GetNextNFactorChallenge(USER)
			\STATE NF.SigParam.User $\leftarrow$ USER
			\STATE NF.SigParam.Challenge $\leftarrow$ C2
			\STATE NF.SigParam.Certificate $\leftarrow$ USER.Public
			\STATE NF.SigParam.Signature $\leftarrow$ SIGN(NF.SigParam, USER.Private)
			\RETURN RESPONSE(NF)
		\ELSE
			\RETURN RESPONSE(ERROR)
		\ENDIF
	\end{algorithmic}
\end{algorithm}

Process 6 show how the identity provider has to delegate messages from the browser to the authentication provider and vice versa. In this case the n-factor challenge is to be delegated. If the authentication provider returned an error or the identity provider cannot verify the n-factor challenge received, a SAML response message indicating an error will be returned to the browser. If the n-factor challenge is verified, it is then delegated to the browser.
\begin{algorithm}[H]
	\caption{Process 6}
	\begin{algorithmic}
		\STATE SigParams $\leftarrow$ NF.SigParams
		\IF{VERIFY(SigParams, SigParams.Signature, SigParams.Certificate)}
			\STATE \textbf{Delegate} NF \TO Browser
		\ELSE
			\STATE \textbf{Delegate} ERROR \TO Browser
		\ENDIF
	\end{algorithmic}
\end{algorithm}

The browser also verifies that the n-factor challenge is valid in process 6.1. An attempt to authenticate the n-factor challenge is then performed. Due to the challenges genericity, the authentication process will not be further described.
\begin{algorithm}[H]
	\caption{Process 6.1}
	\begin{algorithmic}
		\STATE SigParams $\leftarrow$ NF.SigParams
		\IF{VERIFY(SigParams, SigParams.Signature, SigParams.Certificate)}
			\STATE AUTHENTICATE(NF)
		\ELSE
			\PRINT ERROR
		\ENDIF
	\end{algorithmic}
\end{algorithm}

In process 6.2, the genericity of the n-factor challenges once more results in a minimal description. The way the authentication attempts will be handled depends on the n-factor challenge. Therefore to simplify the description, it is assumed that a result conforming to a specific template is returned.
\begin{algorithm}[H]
	\caption{Process 6.2}
	\begin{algorithmic}
		\STATE NFR $\leftarrow$ NFactorResult(NF)
		\RETURN RESPONSE(NFR)
	\end{algorithmic}
\end{algorithm}

Process 6.5 describes the handling of a n-factor challenge result. First off, the n-factor challenge is verified to make sure that it has not been altered. Then it is checked whether or not the n-factor challenge result is acceptable for the n-factor challenge. In the case of acceptance the user is fetched. If the user has not yet completed all n-factor challenges required to authenticate at the authentication provider, then the next challenge is fetched, signed and returned to the user. Process 6 to 6.5 is then repeated until no more n-factor challenges are required, in which case login data for the user is created and returned to the identity provider. In case of the n-factor challenge not passing verification or the n-factor challenge result is not accepted a SAML message indicating an error is returned.
\begin{algorithm}[H]
	\caption{Process 6.5}
	\begin{algorithmic}
		\REQUIRE{User identifiable by (NF.SigParams.USER, NF.SigParams.Certificate)}
		\STATE SigParams $\leftarrow$ NF.SigParams
		\IF{VERIFY(SigParams, SigParams.Signature, SigParams.Certificate)}
			\IF{NFR is acceptable result of NF}
				\STATE USER $\leftarrow$ GetUser(SigParams.USER, SigParams.Certificate)
				\STATE C2 $\leftarrow$ GenChallenge()
				\IF{USER.HasNextChallenge}
					\STATE NF $\leftarrow$ GetNextNFactorChallenge(USER)
					\STATE NF.SigParams.User $\leftarrow$ USER
					\STATE NF.SigParams.Challenge $\leftarrow$ C2
					\STATE NF.SigParams.Certificate $\leftarrow$ USER.Public
					\STATE NF.SigParams.Signature $\leftarrow$ SIGN(NF.SigParams, USER.Private)
					\RETURN RESPONSE(NF)
				\ELSE
					\STATE LID $\leftarrow$ CreateLogInData(USER)
					\STATE ST $\leftarrow$ "OK"
					\RETURN RESPONSE(ST, LID)
				\ENDIF
			\ELSE
				\RETURN RESPONSE(ERROR)
			\ENDIF
		\ELSE
			\RETURN RESPONSE(ERROR)
		\ENDIF	
	\end{algorithmic}
\end{algorithm}

In process 7 it is described how the identity provider handles when a user has been authenticated at the authentication provider. If the returned status does not equal an acceptance criteria, the status is returned to the browser to indicate an error. When the status is accepted the cookie created in process 3 is fetched and the contents of the cookie are extracted.
\par
The initial AuthnRequest extracted from the cookie is verified. Verification failure results in the user being redirected to the service provider with information indicating that the AuthnRequest could not be granted.
\par
When verification succeeds, an assertion is build based on the login data received from the authentication provider. The assertion is then encrypted using the service providers public key. A SAML response is created and the assertion is appended to it along with the AuthnRequest. The browser is then redirected to the service provider.
\begin{algorithm}[H]
	\caption{Process 7}
	\begin{algorithmic}
		\REQUIRE{SP.Public \AND LID is well-formed \AND ARC cookie present}
		\IF{ST = "OK"}
			\STATE MA $\leftarrow$ ARC.AR
			\STATE SAR $\leftarrow$ ARC.SAR
			\STATE RS $\leftarrow$ ARC.RS
			\STATE AR $\leftarrow$ DeflateDecompress(Base64Dec(UrlDec(MA)))
			\IF{VERIFY(AR, SAR, SP.Public)}
				\STATE A $\leftarrow$ BuildAssertion(LID.Certificate)
				\STATE SI $\leftarrow$ GenerateSessionIndex()
				\STATE A.InResponseTo $\leftarrow$ AR
				\STATE A.Issuer $\leftarrow$ IdP
				\STATE A.Audience $\leftarrow$ SP
				\STATE A.SessionIndex $\leftarrow$ SI
				\STATE A.Signature $\leftarrow$ SIGN(A, IdP.Private)
				\STATE EA $\leftarrow$ ENCRYPT(A, SP.Public)
				\STATE RE $\leftarrow$ CreateResponse()
				\STATE RE.Assertion $\leftarrow$ EA
				\STATE RE.InResponseTo $\leftarrow$ AR
				\STATE RE.Status $\leftarrow$ "Success"
				\STATE MRE $\leftarrow$ DeflateCompress(Base64Enc(UrlEnc(RE)))
				\STATE SAS $\leftarrow$ CreateSAMLSession(SI, SP, LID.CertificateSubject)
				\RETURN REDIRECT(SP, MRE, RS, SAS)
			\ELSE
				\STATE RE $\leftarrow$ CreateResponse()
				\STATE RE.InResponseTo $\leftarrow$ AR
				\STATE RE.Status $\leftarrow$ "Requester"
				\STATE MRE $\leftarrow$ DeflateCompress(Base64Enc(UrlEnc(RE)))
				\RETURN REDIRECT(SP, MRE, RS)
			\ENDIF	
		\ELSE
			\RETURN RESPONSE(ST)
		\ENDIF
	\end{algorithmic}
\end{algorithm}

Process 9 describes the last step in the diagram. The SAML response is received at the service provider. The assertion is decrypted and verified. If the verification fails an error message is returned to the browser. If the verification succeeds, an AuthKey is generated. If the user supplies the AuthKey in subsequent requests to the service provider, the service provider will know that the user is already authenticated, thereby eliminating the need to authenticate again until the AuthKey expires. The initial requested resource is retrieved and returned to the browser together with the AuthKey.
\begin{algorithm}[H]
	\caption{Process 9}
	\begin{algorithmic}
		\REQUIRE{POST is well.formed \AND SP.Private \AND IdP.Public}
		\STATE RE $\leftarrow$ UrlDec(Base64Dec(DeflateDecompress(MRE)))
		\STATE A $\leftarrow$ DECRYPT(RE.Assertion, SP.Private)
		\IF{VERIFY(A, A.Signature, IdP.Public)}
			\STATE AK $\leftarrow$ GenAuthKey()
			\STATE R $\leftarrow$ Base64Dec(UrlDec(RS))
			\STATE RES $\leftarrow$ GetResource(R)
			\RETURN RESPONSE(RES, AK)
		\ELSE
			\RETURN RESPONSE(403, Forbidden)
		\ENDIF
	\end{algorithmic}
\end{algorithm}

This concludes the formalizing of the OpenNemID protocol and processing, the subsequent chapter will show how to transform this model into an executable modal using F*.

\chapter{Modelling with F*}
We briefly introduced F* in chapter \ref{chap:techbg}, but will now give a more detailed introduction. F* can be used to model a security protocol. Despite being a formal specification language F* is also executable. F* is described as a \emph{A Verifying Compiler for Distributed Programming}. This chapter will describe how we have used F* to build a formal specification of OpenNemID.

\section{Introducing F*}
F* is a research language from Microsoft Research. F* primarily subsumes two research languages from Microsoft Research, F7\footnote{http://research.microsoft.com/en-us/projects/f7/} and Fine\footnote{http://research.microsoft.com/en-us/projects/fine/}. F* is at this time considered to be an $\alpha$-release. The purpose of designing F* is to enable the construction and communication of proofs of program properties and of properties of a program's environment in a verifiable secure way. F* is a dialect of ML and compiles to .NET bytecode in a type-preserving style. This means that it can interop with other .NET languages and the types defined in F* can be used by other .NET languages without losing type information. Furthermore there also exists a fully abstract compiler from F* to JavaScript. This makes it possible to deploy F* programs on web pages as JavaScript meanwhile there is a formal guarantee that the program still behaves just as they would according to F* semantics. The compiling and type-checking of F* code utilizes the Z3\footnote{http://z3.codeplex.com/} SMT solver for proving assumptions made with refinement types. F* has been formalized and verified using Coq\footnote{Coq is an interactive theorem prover written in OCaml.}.

\section{Syntax and semantics}
F* inherits syntax and semantics from ML. F* is a functional language which means that it has features like immutability by default, polymorphic types and type inference. In Listing \ref{list:helloworld} we have shown the classic Hello World example in F*. This example shows how to specify a main method by defining a function \_ (underscore) at the end of a module. This will instruct the compiler to make an .exe file instead of a dll (dynamic-link library).

\begin{lstlisting}[style=fstar, caption={Hello World example in F*}, label={list:helloworld}]
	module HelloWorld
	
	let _ = print "Hello world!"
\end{lstlisting}

The example in Listing \ref{list:multiply} shows how to explicitly specify types with the \emph{colon} operator and the \emph{val} declaration for defining function signatures. This example defines the function multiply that takes two integers as parameters and returns an integer. After that it defines the corresponding \emph{let} binding which defines that the multiply function multiplies the 2 arguments. It is important to note that not defining the corresponding let binding will not cause the compilation to fail but give the following warning: \emph{Warning: Admitting value declaration Multiplication.multiply as an axiom without a corresponding definition}. So the value declaration was valid but there is no concrete implementation supporting this claim.

\begin{lstlisting}[style=fstar, caption={Multiplication example in F*}, label={list:multiply}]
	module Multiplication

	val multiply: x:int -> y: int -> int
	
	let multiply x y = x * y
	
	let mul = multiply 3 4
\end{lstlisting}

\section{Refinement types}
F* has derived the feature refinement types from the Microsoft Research projects, F7 and Fine. Refinement types are used to make type safe refinements of existing types. Thus it is possible to restrict or refine values more than their original type. Listing \ref{list:refinement} shows an example with the refinement \emph{nat} of int that states that nat will always be zero or larger, i.e. a natural number. The example also shows an attempt to assign -1 to a type of nat which will fail type checking.
\clearpage
\begin{lstlisting}[style=fstar, caption={Simple refinement types in F*}, label={list:refinement}]
	(*Declare a type nat of natural numbers*)	
	type nat = i:int{0 <= i}
	
	let x:nat = 1
	let y:nat = 0
	let z:nat = 1 - 2 (*Will fail type check*)
\end{lstlisting}

Refinement types have the form $x:t\{t'\}$ as shown above. So a refinement type is created by taking an existing type and decorating it with an expression in curly brackets. In the example above the refinement type is a simple boolean expression but refinements are not limited to boolean expression. This is extended in F* through its kind-system.

\subsection{Kinds}
Kinds can be seen as an abstraction over types - types can either \emph{have} or be \emph{of} a kind. The *-kind indicates 'regular types' in F*. This covers all the possible types to create in a regular type system for a programming language like Java. Refinement types are of the E-kind and not of the *-kind. The E(rasable)-kinds have no significance at runtime. They only have an effect at the compiling time during type checking.

\section{Understanding F*}
Since we are extending Jacob's work with the authentication part of the protocol we used his code as a reference for implementing the rest of the OpenNemID protocol. In listing \ref{list:nemididp} we show Jacob's implementation of the Identity Provider. He has implemented a recursive function \emph{identityprovider} declared with the val binding just above it. The function declared takes 2 arguments and returns \emph{unit}, which is the same as void in Java and C\#.
\\
\\
\textbf{The arguments}
\begin{enumerate}
\item a principal for identifying the identity provider
\item a principal for identifying the client.
\end{enumerate}
\clearpage
\begin{lstlisting}[style=fstar, caption={[NemID identity provider implementation]NemID identity provider implementation \cite{jacob}}, label={list:nemididp}]
	module Identityprovider

	open SamlProtocol
	open Crypto

	let handleUserAuthenticated me user client authnrequest =
	  match authnrequest with 
  	| MkAuthnRequest(reqid,issueinst,dest,sp,msg,sigSP) ->
   	   let pubksp = CertStore.GetPublicKey sp in
  	    if (VerifySignature sp pubksp msg sigSP) then
  	      (assert (Log sp msg);
 	       let assertion = IssueAssertion me user sp reqid in
 	       let myprivk = CertStore.GetPrivateKey me in
 	       assume(Log me assertion);
  	      let sigAs = Sign me myprivk assertion in
	        let signAssertion = AddSignatureToAssertion assertion sigAs in
	        let encryptedAssertion = EncryptAssertion sp pubksp 
signAssertion in
  	      let resp = AuthResponseMessage me sp encryptedAssertion in
	        SendSaml client resp) (*10*)
	      else
	        SendSaml client (Failed Requester)(*10.2*)

	val identityprovider: me:prin -> client:prin -> unit

	let rec identityprovider me client =
		let req = ReceiveSaml client in (*3 & 11*)
		match req with
		| AuthnRequestMessage (issuer, destination, message, sigSP) ->
 	   let pubkissuer = CertStore.GetPublicKey issuer in
	    if (VerifySignature issuer pubkissuer message sigSP) then
	      (assert (Log issuer message);
 	     let challenge = GenerateNonce me in
	      let resp = UserCredRequest challenge in
	      SendSaml client resp; (*4*)
	      identityprovider me client (*Start over*))
	    else
	      SendSaml client (Failed Requester);(*4.1*)
	      identityprovider me client (*Start over*)
	  | UserAuthenticated (status, logindata, authnrequest) ->
	    match logindata with 
	    | MkLoginData (user,sig,cert,challenge,site,data) ->
	      if (status = "OK") && (VerifySignature user cert data sig) then
	        (assert (Log user data);
	          handleUserAuthenticated me user client authnrequest;
	          identityprovider me client) (*Start over*)
	      else
	        SendSaml client (DisplayError 400);(*10.1*)
	        identityprovider me client (*Start over*)
 	 | _ -> SendSaml client (DisplayError 400);(*10.1*)
  	      identityprovider me client (*Start over*)
\end{lstlisting}

The recursive function \emph{identityprovider} starts by receiving a SAML message from the client. It then matches the request with a \emph{SamlMessage.AuthnRequestMessage} or\emph{SamlMessage.UserAuthenticated} type. When matched with an AuthnRequest message it verifies the service providers signature of the message by the function \emph{VerifySignature} which is shown in Listing \ref{list:crypelm}. The function takes a principal, the principals public key, a message and a signature. It returns a boolean indicating if the check passed. The return type however has a refinement type that relates the message to the principal if the verification passes. $==>$ should be seen as an implication therefore stating that the predicate is valid. If the verification of the service providers signature of the AuthnRequestMessage passes it creates a nonce to be related to this user when the user has authenticated himself/herself by NemID and sends the response to the user. When the user has authenticated through NemID the function \emph{handleUserAuthenticated} is called. The purpose of the function is to issue a signed assertion and sending the AuthResponseMessage to the user. The signature for signing messages takes 4 arguments - the principal, the signer, the private key of the principal and the message to be signed. The message is annotated with a refinement type \emph{\{Log p msg\}}. This refinement type is an E-kinded type that takes a principal and a string as constructor elements. The val declaration for a method \emph{Sign} in Listing \ref{list:crypelm} requires the predicate \{Log p msg\} to be true before it can type check. This means that the message to sign is related to the principal signing the message. Securing this is done by calling \emph{assume\{Log me assertion\}} before signing the message. The predicate is by virtue of this "verified". After this the assertion is encrypted by using the service providers public key and sent within an AuthResponseMessage to the user.

\begin{lstlisting}[style=fstar, caption={Cryptographic elements}, label={list:crypelm}]
	type pubkey :: prin => *
	type privkey :: prin => *

	type Log :: prin => string => E
	
	val Sign: p:prin
		-> privkey p
		-> msg:string{Log p msg}
		-> dsig

	val VerifySignature: p:prin
		-> pubkey p 	
		-> msg:string
		-> dsig
		-> b:bool{b=true ==> Log p msg}
\end{lstlisting}

In listing \ref{list:crypelm} we show the declaration of the types for private key (\emph{privkey}) and public key (\emph{pubkey}). These types are declared by using the F* syntax for constructing dependent types (the double colon). This means that a type \emph{pubkey} will have a constructor that takes a \emph{prin} (principal) and returns a type of *-kind. This is still abstract and the type has no actual constructor.

\section{OpenNemID specified in F*}
The code in this section represents the state of the project now. This is in no way a complete implementation of the protocol. Implementation was carried out in an incremental manner. First the focus was on understanding Jacob's work and expanding that with the authentication part (Authentication Provider) of the protocol, which before was done by DanID, and then adding the functionality of creating the login, establishing a connection between Identity Provider and the Authentication Provider and so on. All source code that has been produced in this project can be found on the source code sharing community Github\footnote{https://github.com/kiniry-supervision/OpenNemID}.
\\The F* code for the protocol is organized in 10 modules:
\begin{enumerate}
	\item The TypeFunc module
	\item The SamlProtocol module
	\item The Crypto module
	\item The CertStore module
	\item The Messaging module
	\item The Service Provider module
	\item The Identity Provider module
	\item The Database module
	\item The Authentication Provider module
	\item The Browser module
\end{enumerate}
The modeling follows the principles for cryptographic protocol modeling outlined by Dolev \& Yao\footnote{Cryptographic primitives are assumed perfect and cyphers cannot be decrypted without the the proper decryption key}. In the following we will explain the important principles for each module and the relation to the algorithms outlined in chapter \ref{chap:modelspecify}.

\subsection{Specification of the type functionality module}
\begin{lstlisting}[style=fstar, caption={TypeFunc module}]
	module TypeFunc

	type Authentication =
		| OpenId: id:int -> Authentication
		| Facebook: id:int -> Authentication
		| SMS: generated:int -> Authentication
		| Yubico: generated:int -> Authentication
\end{lstlisting}

The \emph{TypeFunc} module provides the type Authentication which is used for the different kinds of n-factor authentication. Note that currently there is only an id associate with each type of authentication for simplicity. This needs to be modified so that each type is more explicit and holds the correct information for authentication.

\subsection{Specification of the SAML Protocol}
\begin{lstlisting}[style=fstar, caption={Specification of the SAML Protocol elements}]
	module SamlProtocol
	
	open Crypto
	open TypeFunc

	type assertiontoken = string (*Add refinements*)
	type signedtoken = string (*Add refinements*)
	type id = string
	type endpoint = string
	type uri = string


	type AuthnRequest = 
	  | MkAuthnRequest: IssueInstant:string ->
			    Destination:endpoint -> Issuer:prin ->
			    message:string -> sig:dsig ->
			    AuthnRequest

	type LoginData = 
	  | MkLoginData:  user:prin -> signature:dsig ->
			  cert:pubkey user -> challenge:nonce ->
			  site:string -> data:string ->
			  LoginData

	type LoginInfo =
	  | UserLogin:  userid:string -> password:string ->
			LoginInfo

	type AuthInfo =
	  | UserAuth:   userid:string -> authmethod:Authentication ->
			authresponse:Authentication -> AuthInfo

	type Assertion =
	  | SignedAssertion: assertiontoken -> dsig -> Assertion
	  | EncryptedAssertion: cypher -> Assertion

	type SamlStatus =
	  | Success: SamlStatus
	  | Requester: SamlStatus
	  | Responder: SamlStatus

	type LoginError =
	  | AuthError: LoginError
	  | CredentialError: LoginError

	type SamlMessage =
	  | SPLogin: uri -> SamlMessage
	  | Login: loginInfo:LoginInfo -> challenge:nonce -> SamlMessage
	  | LoginResponse: string -> SamlMessage
	  | AuthnRequestMessage: issuer:prin ->  destination:endpoint -> message:string -> dsig -> SamlMessage
	  | LoginRequestMessage: issuer:prin ->  destination:endpoint -> loginInfo:LoginInfo -> SamlMessage 
	  | NfactAuthRequest: issuer:prin -> destination:endpoint -> authInfo:AuthInfo -> challenge:nonce -> dsig -> SamlMessage
	  | AuthResponseMessage: issuer:prin -> destination:endpoint -> Assertion -> SamlMessage
	  | LoginResponseMessage: issuer:prin -> destination:endpoint -> auth:Authentication -> challenge:nonce -> dsig -> SamlMessage
	  | UserAuthenticated: status:string -> logindata:LoginData -> authnReq:AuthnRequest -> SamlMessage
	  | UserCredRequest: javascript:string -> challenge:nonce -> dsig -> SamlMessage
	  | UserAuthRequest: authmethod:Authentication -> challenge:nonce -> dsig -> SamlMessage
	  | UserAuthResponse: authInfo:AuthInfo -> challenge:nonce -> dsig -> SamlMessage
	  | LoginSuccess: status:string -> issuer:prin -> destination:endpoint -> SamlMessage
	  | Failed: SamlStatus -> SamlMessage
	  | LoginFailure: LoginError -> SamlMessage
	  | DisplayError: int -> SamlMessage


	val SendSaml: prin -> SamlMessage -> unit
	val ReceiveSaml: prin -> SamlMessage 

	val CreateAuthnRequestMessage: issuer:prin -> destination:prin -> string
	val IssueAssertion: issuer:prin -> subject:prin -> audience:prin -> inresto:AuthnRequest -> assertiontoken
	val AddSignatureToAssertion: assertiontoken -> dsig -> signedtoken
	val EncryptAssertion: receiver:prin -> pubkey receiver -> signedtoken -> Assertion
	val DecryptAssertion: receiver:prin -> privkey receiver -> Assertion -> (signedtoken * dsig)
\end{lstlisting}

The \emph{SamlProtocol} module is taken directly from Jacob's code and only modified to support more and different \emph{SamlMessages} that are needed in our specification of OpenNemID. The purpose of this module is the specification of messages and to provide functions for sending and receiving messages. Note that the functions for sending and receiving messages have no runtime implementation. They are only specified by the val declaration. The SAML Protocol is used for the communication between the principals in the OpenNemID protocol in a login session. The intention with these functions are that they will handle the mapping of protocol elements to the network.
\clearpage
\subsection{Specification of cryptographic elements}
\begin{lstlisting}[style=fstar, caption={Specification of cryptographic elements}]
	module Crypto
	
	open Protocol
	open TypeFunc

	type prin = string
	type pubkey :: prin => *
	type privkey :: prin => *
	type dsig
	type nonce = string
	type cypher
	(*Verification*)
	type Log :: prin => string => E

	type LogAuth :: prin => Authentication => E

	val Keygen: p:prin
		  -> (pubkey p * privkey p)

	val Sign: p:prin
		-> privkey p
		-> msg:string{Log p msg}
		-> dsig

	val SignAuth: p:prin
		-> privkey p
		-> msg:Authentication{LogAuth p msg}
		-> dsig

	val VerifySignature: p:prin
		-> pubkey p 
		-> msg:string
		-> dsig
		-> b:bool{b=true ==> Log p msg}

	val VerifySignatureAuth: p:prin
		-> pubkey p 
		-> msg:Authentication
		-> dsig
		-> b:bool{b=true ==> LogAuth p msg}

	val Encrypt: p:prin
		-> pubkey p
		-> string
		-> cypher

	val Decrypt: p:prin
		-> privkey p
		-> cypher
		-> string

	val GenerateNonce: prin -> nonce (*Add refinement to ensure unqueness*)
\end{lstlisting}

The \emph{crypto} module is taken directly from Jacob's code and only modified to support signing and verification of the authentication type. The purpose of the crypto module is providing the cryptographic functions to sign and verify both messages and the authentication type and also the encryption and decryption of messages. The crypto module utilizes a refinement type to ensure that signed messages and authentications have typed dependency to the signing principal. It does not have a concrete implementation as of now.
\subsection{Specification of certificate store module}

\begin{lstlisting}[style=fstar, caption={Abstract certificate store}]
	module CertStore
	
	open Crypto

	val GetPublicKey: p:prin -> pubkey p
	val GetJSPublicKey: p:prin -> pubkey p
	(*Prin needs to be updated to include credentials*)
	val GetPrivateKey: p:prin -> privkey p 
	val GetJSPrivateKey: p:prin -> privkey p
\end{lstlisting}

The \emph{CertStore} module is taken from Jacob's code and expanded with functionality to support JavaScript public and private keys. This module provides four abstract functions for retrieving certificates from a certificate store. The functions use the value dependent syntax for relating a principal to the certificate keys. As Jacob has written in a comment the principal could be updated to include credentials because this is a quite naive implementation. It is naive because all you need to obtain the private key of a principal, is the name of the principal.

\clearpage
\subsection{Specification of the messaging protocol}
\begin{lstlisting}[style=fstar, caption={Specification of the Messaging protocol}]
	module Messaging
	
	open Crypto
	open TypeFunc

	type Status =
		| Successful: Status
		| Unsuccessful: Status

	type Message =
		| NewSiteRequest: idp:prin -> Message
		| ChallengeResponse: challenge:nonce -> Message
		| IdpChalResponse: challenge:nonce -> Message
		| AcceptedIdp: idp:prin -> pubkey:pubkey idp -> authp:prin -> authpubkey:pubkey authp -> signedjavascript:string -> Message
		| RequestForLogin: passportnumber:string -> Message
		| ReqLoginResponse: challenge:nonce -> Message
		| CreateLogin: generatedpassword:string -> challenge:nonce -> Message
		| ChangeUserId: userid:string -> newUserId:string -> password:string -> Message
		| ChangePassword: userid:string -> password:string -> newPassword:string -> Message
		| UserRevokeIdp: userid:string -> password:string -> idp:string -> Message
		| AddNfactor: userid:string -> password:string -> nfact:Authentication -> Message
		| RemoveNfactor: userid:string -> password:string -> nfact:Authentication -> Message
		| StatusMessage: Status -> Message


	val SendMessage: prin -> Message -> unit
	val ReceiveMessage: prin -> Message
\end{lstlisting}

The \emph{Messaging} module is responsible for two things, the specification of messages and providing functions for sending and receiving these messages. As the SamlProtocol module the functions for sending and receiving are specified only by the val declaration and has no concrete runtime implementation. This module is used to model the communication between the identity provider and the authentication provider, when wanting to establish a secure connection. The module is also used to model the creating or changing the login of a user.

\clearpage
\subsection{Specification of the Service Provider}
\begin{lstlisting}[style=fstar, caption={Specification of service provider}]
	module Serviceprovider
	
	open SamlProtocol
	open Crypto
	
	val serviceprovider:  me:prin -> client:prin -> idp:prin -> unit
	
	let rec serviceprovider me client idp = 
	 let req = ReceiveSaml client in
	 match req with
	  | SPLogin (url) ->
	    let authnReq = CreateAuthnRequestMessage me idp in
	    assume(Log me authnReq);
	    let myprivk = CertStore.GetPrivateKey me in
	    let sigSP = Sign me myprivk authnReq in
	    let resp = AuthnRequestMessage me idp authnReq sigSP in 
	    SendSaml client resp;
	    serviceprovider me client idp
	  | AuthResponseMessage (issuer, destination, encassertion) -> 
	    let myprivk = CertStore.GetPrivateKey me in
	    let assertion = DecryptAssertion me myprivk encassertion in
	    match assertion with
	    | SignedAssertion (token,sigIDP) ->
	      let pubkissuer = CertStore.GetPublicKey idp in
	      if VerifySignature idp pubkissuer token sigIDP
	      then
	        (assert(Log idp token);
	        let resp = LoginResponse "You are now logged in" in
	        SendSaml client resp)
	      else SendSaml client (DisplayError 403);
	      serviceprovider me client idp
	  
	  | _ -> SendSaml client (DisplayError 400);
	        serviceprovider me client idp
\end{lstlisting}

The service provider is taken directly from Jacob's code and it is not modified in any way. The service provider implements algorithm 1 and 11 in Section \ref{sect:communicationmodal}. The module is constructed to accept SAML messages of type \emph{SPLogin} and \emph{AuthResponseMessage}. If the service provider receives another type of message it will return a HTTP error. Contrary to algorithms 1 and 11 the service provider does not implement encoding and decoding because this is expected to be handled by the SamlProtocol module.

\clearpage
\subsection{Specification of the Identity Provider}
The specification of the identity provider is divided into several listings for the sake of understandability.

\begin{lstlisting}[style=fstar, caption={Handling and delegation of a user's requests}]
	module Identityprovider

	open SamlProtocol
	open Crypto
	open TypeFunc
	open Messaging

	val userloggedin: user:prin -> bool
	val getjavascript: string
	val userlogin: user:prin -> unit
	val decodeMessage: message:string -> AuthnRequest
	val getauthnrequest: user:prin -> challenge:nonce -> AuthnRequest
	val getuserchallenge: user:prin -> nonce
	val relatechallenge: user:prin -> challenge:nonce -> unit
	val verifychallenge: user:prin -> challenge:nonce -> bool
	val relate: user:prin -> challenge:nonce -> authnReq:AuthnRequest -> unit

	val identityprovider: me:prin -> user:prin -> authp:prin -> unit

	let rec identityprovider me user authp =
		let request = ReceiveSaml user in
		match request with
		| AuthnRequestMessage(issuer, destination, message, sigSP) ->
			let pubkissuer = CertStore.GetPublicKey issuer in
		if (VerifySignature issuer pubkissuer message sigSP) then
			(assert (Log issuer message);
			let authnReq = decodeMessage message in
			let myprivk = CertStore.GetPrivateKey me in
			if not (userloggedin user) then
				let challenge = GenerateNonce me in
				relate user challenge authnReq;
				relatechallenge user challenge;
				let js = getjavascript in
				assume(Log me js);
				let myprivk = CertStore.GetJSPrivateKey me in
				let sigIdP = Sign me myprivk js in
				let resp = UserCredRequest js challenge sigIdP in
				SendSaml user resp;
				identityprovider me user authp
			else
				let assertion = IssueAssertion me user issuer authnReq in
				assume(Log me assertion);
				let myprivk = CertStore.GetPrivateKey me in
				let pubksp = CertStore.GetPublicKey issuer in
				let sigAs = Sign me myprivk assertion in
				let signAssertion = AddSignatureToAssertion assertion sigAs in
				let encryptedAssertion = EncryptAssertion issuer pubksp signAssertion in
				let resp = AuthResponseMessage me issuer encryptedAssertion in
				SendSaml user resp)
		else
			SendSaml user (Failed Requester);
			identityprovider me user authp
		| Login (loginInfo, challenge) ->
			if (verifychallenge user challenge) then
				let req = LoginRequestMessage me authp loginInfo in
				SendSaml authp req;
				handleauthresponse me user authp;
				identityprovider me user authp
			else
				SendSaml user (DisplayError 400);
				identityprovider me user authp
		| UserAuthResponse(authInfo, challenge, sigAuth) ->
			let req = NfactAuthRequest me authp authInfo challenge sigAuth in
			SendSaml authp req;
			handleauthresponse me user authp;
			identityprovider me user authp
		| _ -> SendSaml user (DisplayError 400);
			identityprovider me user authp
\end{lstlisting}

This part of the identity provider implements algorithm 2. The identity provider accepts the three SAML messages \emph{AuthnRequestMessage}, \emph{Login} and \emph{UserAuthResponse} from the user.
\begin{enumerate}
\item The \emph{AuthnRequestMessage} branch decodes the message and if the user has not logged in previously it sends a \emph{UserCredRequest} back with the JavaScript and a nonce to be used for relating the login at the Identity Provider prompting the user to give his or her login information. If the user has already logged in previously it issues an assertion to the user. The check for checking if a user is logged in is checking for cookies previously sat by the Identity Provider.
\item The \emph{Login} branch handles login information of the user which is the response the user provides after receiving the \emph{UserCredRequest}. This branch verifies that the nonce from the user is the correct one and if it is correct it delegates the login information to the Authentication Provider and then calls the function \emph{handleauthresponse} which we will explain later in this section. If the nonce is incorrect it returns a HTTP error.
\item The \emph{UserAuthResponse} branch handles the user's n-factor authentication information and delegates the information to the Authentication Provider.
\end{enumerate}

\clearpage
\begin{lstlisting}[style=fstar, caption={The handling of the responses from Authentication Provider}]
	val handleUserAuthenticated: me:prin -> user:prin -> authnReq:AuthnRequest -> unit

	let handleUserAuthenticated me user authnReq = 
		match authnReq with
		| MkAuthnRequest(issueinst,dest,sp,msg,sigSP) ->
			let pubksp = CertStore.GetPublicKey sp in
				if (VerifySignature sp pubksp msg sigSP) then
			(assert (Log sp msg);
			let assertion = IssueAssertion me user sp authnReq in
			let myprivk = CertStore.GetPrivateKey me in
			assume(Log me assertion);
			userlogin user;
			let sigAs = Sign me myprivk assertion in
			let signAssertion = AddSignatureToAssertion assertion sigAs in
			let encryptedAssertion = EncryptAssertion sp pubksp signAssertion in
			let resp = AuthResponseMessage me sp encryptedAssertion in
			SendSaml user resp)
	      else
		SendSaml user (Failed Requester)

	val handleauthresponse: me:prin -> user:prin -> authp:prin -> unit

	let handleauthresponse me user authp =
		let resp = ReceiveSaml authp in
		match resp with
		| LoginResponseMessage(issuer, destination, authmethod, challenge, sigUser) ->
			let pubkeyuser = CertStore.GetPublicKey user in
			if VerifySignatureAuth user pubkeyuser authmethod sigUser then
				(assert (LogAuth user authmethod);
				relatechallenge user challenge;
				let resp = UserAuthRequest authmethod challenge sigUser in
				SendSaml user resp)
			else
				SendSaml user (DisplayError 403)
		| LoginSuccess(status, issuer, destination) ->
			if (status = "OK") then
				let challenge = getuserchallenge user in
				let authnReq = getauthnrequest user challenge in
				handleUserAuthenticated me user authnReq
			else 
				SendSaml user (DisplayError 403)
		| _ -> SendSaml user (DisplayError 400)
\end{lstlisting}

This part of the identity provider handles the information received from the authentication provider. It implements algorithms 6 and 7. The function \emph{handleauthresponse} has two match branches:
\clearpage
\begin{enumerate}
\item \emph{LoginResponseMessage} which will prompt the user for a n-factor authentication method while it relates the challenge generated by the authentication provider to the user for verification
\item \emph{LoginSuccess} which specifies that the user has passed all the n-factor authentication methods. 
\end{enumerate}

If the user has been successfully logged in the user will be issued an assertion which is done in the \emph{handleUserAuthenticated} function. This function will also save a cookie that specifies that this user has logged in which the identity provider will check for when getting an AuthnRequestMessage from a user.

\begin{lstlisting}[style=fstar, caption={Establising a secure connection with Authentication Provider}]
	val savejavascript: javascript:string -> unit
	val savepublickey: owner:prin -> publickey:pubkey owner -> unit

	val connectwithauthp: me:prin -> authp:prin -> unit

	let connectwithauthp me authp =
		let req = NewSiteRequest me in
		let _ = SendMessage authp req in
		let resp = ReceiveMessage authp in
		match resp with
		| ChallengeResponse(challenge) ->
			let _ = SendMessage authp (IdpChalResponse challenge) in
			let res = ReceiveMessage authp in
			match res with
			| AcceptedIdp(idp, idppubkey, authp, authppubkey, signedjs) ->
				(*Established secure connection*)
				savejavascript signedjs;
				savepublickey authp authppubkey;
				savepublickey idp idppubkey
			| _ -> res; ()
		| _ -> resp; ()
\end{lstlisting}

This part of the identity provider is the establishing of the secure connection between the identity provider and the authentication provider. Right now the challenge response from the authentication provider is just a nonce to illustrate that the identity provider needs to be investigated thoroughly by the authentication provider for the purpose of finding out if it is a malicious identity provider.

\clearpage
\subsection{Specification of the Database Handler}
\begin{lstlisting}[style=fstar, caption={Specification of the database}]
	module Database
	
	open Crypto
	open CertStore
	open TypeFunc

	(*Identity provider functionality*)
	val whitelist: idp:prin -> unit
	val blacklist: idp:prin -> unit
	val addidp: idp:prin -> bool
	val whitelisted: idp:prin -> bool

	(*User functionality*)
	val createuser: passportnumber:string -> bool
	val usercreation: user:prin -> generatedPassword:string -> bool
	val changeuserid: user:string -> newuser:string -> password:string -> bool
	val changeuserpassword: user:string -> password:string -> newpassword:string -> bool

	val addnfactor: user:string -> password:string -> nfactor:Authentication -> bool
	val removenfactor: user:string -> password:string -> nfactor:Authentication -> bool

	val getnfactor: user:string -> Authentication
	val checknfactor: user:string -> Authentication -> bool
	val allnfactauthed: user:string -> bool
	val resetnfact: user:string -> unit

	val checklogin: user:string -> password:string -> bool

	val revokeidp: user:string -> password:string -> idp:string -> bool

	val revokedidp: user:string -> idp:prin -> bool
\end{lstlisting}

The \emph{Database} module is responsible for the communication with the database and therefore checking the information provided by the user. The database is also responsible for keeping track of how many n-factor authentications the user has gone through. Note that as of now these functions are just specified by the val declaration and therefore has no concrete implementation.

\clearpage
\subsection{Specification of the Authentication Provider}
The specification of the authentication provider is divided into several listings for the sake of understandability.

\begin{lstlisting}[style=fstar, caption={Specification of the authentication provider}]
	module Authenticationprovider

	open SamlProtocol
	open Crypto
	open Database
	open TypeFunc
	open Messaging

	val relatechallenge: user:prin -> challenge:nonce -> unit

	val verifychallenge: user:prin -> challenge:nonce -> bool

	val nfactauth: me:prin -> idp:prin -> user:prin -> userid:string -> unit

	let nfactauth me idp user userid =
		if (allnfactauthed userid) then
			resetnfact userid;
			let status = "OK" in
			let resp = LoginSuccess status me idp in
			SendSaml idp resp
		else
			let challenge = GenerateNonce me in
			let authmethod = getnfactor userid in
			assume(LogAuth user authmethod);
			let userprivkey = CertStore.GetPrivateKey user in
			let sigUser = SignAuth user userprivkey authmethod in
			let resp = LoginResponseMessage me idp authmethod challenge sigUser in
			SendSaml idp resp

	val authenticationprovider: me:prin -> idp:prin -> user:prin -> unit

	let rec authenticationprovider me idp user =
		let req = ReceiveSaml idp in
		match req with
		| LoginRequestMessage (issuer, destination, loginInfo) ->
			if (whitelisted idp) then
				match loginInfo with
				| UserLogin(userid, password) ->
					if not (revokedidp userid idp) && (checklogin userid password) then
						let challenge = GenerateNonce me in
						let authmethod = getnfactor userid in
						assume(LogAuth user authmethod);
						let userprivkey = CertStore.GetPrivateKey user in
						let sigUser = SignAuth user userprivkey authmethod in
						relatechallenge user challenge;
						let resp = LoginResponseMessage me idp authmethod challenge sigUser in
						SendSaml idp resp;
						authenticationprovider me idp user
					else
						SendSaml idp (LoginFailure CredentialError);
						authenticationprovider me idp user
				| _ -> SendSaml idp (Failed Requester);
					authenticationprovider me idp user
			else
				SendSaml idp (Failed Requester);
				authenticationprovider me idp user
		| NfactAuthRequest(issuer, destination, authInfo, challenge, sigAuth) ->
			if (whitelisted idp) then
				match authInfo with
				| UserAuth(userid, authmethod, authresponse) ->
					let userpubkey = CertStore.GetPublicKey user in
					if VerifySignatureAuth user userpubkey authmethod sigAuth && verifychallenge user challenge then
						if not (revokedidp userid idp) && (checknfactor userid authresponse) then
							nfactauth me idp user userid;
							authenticationprovider me idp user
						else
							SendSaml idp (LoginFailure AuthError);
							authenticationprovider me idp user
					else
						SendSaml idp (LoginFailure AuthError);
						authenticationprovider me idp user
				| _ -> SendSaml idp (Failed Requester);
					authenticationprovider me idp user
			else
				SendSaml idp (Failed Requester);
				authenticationprovider me idp user
		| _ -> SendSaml idp (Failed Requester);
			authenticationprovider me idp user
\end{lstlisting}

The authentication provider implements algorithms 5 and 9. The authentication provider accepts two SAML messages \emph{LoginRequestMessage} and \emph{NfactAuthRequest} from the Identity Provider.
\begin{enumerate}
\item The \emph{LoginRequestMessage} branch will check the login information. If the correct login information has been provided by the user it generates a nonce to be related to the user and specifies which type of n-factor authentication the user has to go through and that will be sent to the identity provider.
\item The \emph{NfactAuthRequest} branch is the receiving of n-factor authentication response from the user. It verifies the sender of the message and the n-factor information. The correct n-factor information will call the function \emph{nfactauth} which will handle if the user has gone through all n-factor authentication method or needs to specify more. The function will send the information to the identity provider.
\end{enumerate}

\begin{lstlisting}[style=fstar, caption={The creation and changing of a user's account}]
	val usercommunication: me:prin -> user:prin -> unit

	let rec usercommunication me user =
		let req = ReceiveMessage user in
		match req with
		| RequestForLogin(passportnumber) -> 
			if createuser user passportnumber then
				let challenge = GenerateNonce me in
				relatechallenge user challenge;
				SendMessage user (ReqLoginResponse challenge);
				usercommunication me user
			else
				SendMessage user (StatusMessage Unsuccessful);
				usercommunication me user
		| CreateLogin(generatedpassword, challenge) ->
			if (verifychallenge user challenge) && (usercreation user generatedpassword) then
				let challenge = GenerateNonce me in
				relatechallenge user challenge;
				SendMessage user (StatusMessage Successful);
				usercommunication me user
			else
				SendMessage user (StatusMessage Unsuccessful);
				usercommunication me user
		| ChangePassword(userid, password, newPassword) ->
			if changeuserpassword userid password newPassword then
				SendMessage user (StatusMessage Successful);
				usercommunication me user
			else
				SendMessage user (StatusMessage Unsuccessful);
				usercommunication me user
		| ChangeUserId(userid, newUserId, password) ->
			if changeuserid userid newUserId password then
				SendMessage user (StatusMessage Successful);
				usercommunication me user
			else
				SendMessage user (StatusMessage Unsuccessful);
				usercommunication me user
		| UserRevokeIdp(userid, password, idp) ->
			if revokeidp userid password idp then
				SendMessage user (StatusMessage Successful);
				usercommunication me user
			else
				SendMessage user (StatusMessage Unsuccessful);
				usercommunication me user
		| AddNfactor(userid, password, nfact) ->
			if addnfactor userid password nfact then
				SendMessage user (StatusMessage Successful);
				usercommunication me user
			else
				SendMessage user (StatusMessage Unsuccessful);
				usercommunication me user
		| RemoveNfactor(userid, password, nfact) ->
			if removenfactor userid password nfact then
				SendMessage user (StatusMessage Successful);
				usercommunication me user
			else
				SendMessage user (StatusMessage Unsuccessful);
				usercommunication me user
		| _ -> SendMessage user (StatusMessage Unsuccessful);
			usercommunication me user
\end{lstlisting}

This part of the authentication provider is responsible for creating and changing a user's account. It is pretty straight forward what the different messages does. When creating a login the user will give their passportnumber. Then they will receive a one-time password by mail to verify their account. The database will handle all the information and the checking of the information. We wrote in section \ref{sect:nfactauth} about n-factor authentication and that a user must have at least one method for n-factor authentication. This is not yet enforced by the authentication provider when a user registers an account.

\begin{lstlisting}[style=fstar, caption={Establishing a secure connection with the Identity Provider}]
	val getsignedjavascript: string

	val establishidp: me:prin -> idp:prin -> unit

	let rec establishidp me idp =
		let req = ReceiveMessage idp in
		match req with
		| NewSiteRequest(idp) ->
			let challenge = GenerateNonce me in
			relatechallenge idp challenge;
			SendMessage idp (ChallengeResponse challenge);
			establishidp me idp
		| IdpChalResponse(challenge) ->
			if (verifychallenge idp challenge) && (addidp idp) then
				let idppubkey = CertStore.GetPublicKey idp in
				let mypubk = CertStore.GetPublicKey me in
				let signedjs = getsignedjavascript in
				let resp = AcceptedIdp idp idppubkey me mypubk signedjs in
				SendMessage idp resp;
				establishidp me idp
			else
				SendMessage idp (StatusMessage Unsuccessful);
				establishidp me idp
		| _ -> SendMessage idp (StatusMessage Unsuccessful);
			establishidp me idp
\end{lstlisting}

This part of the authentication provider will handle the establishing of a secure connection between the identity provider and the authentication provider. As we mentioned when we described the identity providers specification of this model there needs to be some investigation of the identity provider and not just a generated nonce. This is just specified to give an idea of how the model is designed.

\subsection{Specification of the Browser}
The specification of the Browser is divided into two listings for the sake of understandability. Note that we can not model the user's input therefore the input from the user is specified by a bunch of val declarations.

\begin{lstlisting}[style=fstar, caption={Browser's side of logging in}]
	module Browser

	open SamlProtocol
	open Crypto
	open CertStore
	open TypeFunc
	open Messaging

	val loginWithFb: Authentication
	val loginWithYubico: Authentication
	val loginWithSMS: Authentication
	val loginWithOpenId: Authentication
	val userid: string
	val password: string
	val fakeprint: str:string -> unit

	val handleAuthMethod: auth:Authentication -> Authentication
	
	let handleAuthMethod auth = 
		match auth with
		| Facebook(fbid) -> loginWithFb
		| SMS(gen) -> loginWithSMS
		| OpenId(oid) -> loginWithOpenId
		| Yubico(yid) -> loginWithYubico
					
	val loop: user:string -> idp:prin -> sp:prin -> unit
	
	let rec loop userid idp sp =
		let loginresp = ReceiveSaml idp in
			match loginresp with
			| UserAuthRequest(authmethod, challenge, sigAuth) ->
				let authresponse = handleAuthMethod authmethod in
				let authInfo = UserAuth userid authmethod authresponse in
				let authresp = UserAuthResponse authInfo challenge sigAuth in
				SendSaml idp authresp;
				loop userid idp sp
			| AuthResponseMessage(idenp, dest, assertion) ->
				SendSaml sp loginresp
			| _ -> loginresp; ()

	val browser: sp:prin -> res:uri -> unit
	
	let browser sp resource =
		let req = SPLogin resource in
		let _ = SendSaml sp req in
			let res = ReceiveSaml sp in
			match res with
			| AuthnRequestMessage(sp, idp, message, sigSP) ->
				let _ = SendSaml idp res in
				let idpResp = ReceiveSaml idp in
				match idpResp with
				| UserCredRequest(javascript, challenge, sigIdP) ->
					let pubkissuer = CertStore.GetJSPublicKey idp in
					if VerifySignature idp pubkissuer javascript sigIdP then 
						(assert (Log idp javascript);
						let loginInfo = UserLogin userid password in
						let loginreq = Login loginInfo challenge in
						SendSaml idp loginreq;
						loop userid idp sp;
						let spResp = ReceiveSaml sp in
						match spResp with
						| LoginResponse(str) ->
								fakeprint str
						| _ -> spResp; ())
					else
						fakeprint "Validation Error"
				| _ -> idpResp; ()
			| _ -> res; ()	
\end{lstlisting}

This part of the \emph{Browser} module is used to model the client's side of a logging in session. It implements algorithms 3 and 7. It is worth noticing that the Browser verifies the JavaScript is actually received from the correct identity provider. The function \emph{fakeprint} is used to give the user messages about errors and if they are logged in. The recursive function \emph{loop} will provide n-factor authentication methods until the client receives a \emph{AuthResponseMessage} which it then will send to the service provider and the user is now logged in.

\begin{lstlisting}[style=fstar, caption={The Browser's side of the account creation and changing}]
	val newUserId: string
	val newPassword: string
	val idpToRevoke:string
	val nfactToRemove: Authentication
	val nfactToAdd: Authentication

	val retrieveGeneratedPassword: string

	val createUser: authp:prin -> passportnumber:string -> unit
	
	let createUser authp passportnumber =m
		let req = RequestForLogin passportnumber in
		let _ = SendMessage authp req in
			let resp = ReceiveMessage authp in
			match resp with
			| ReqLoginResponse(challenge) ->
				let reqlresp = CreateLogin retrieveGeneratedPassword challenge in
				let _ = SendMessage authp reqlresp in
				let createloginresp = ReceiveMessage authp in
				match createloginresp with
				| StatusMessage(status) ->
					match status with
					| Successful -> fakeprint "You have created an account"
					| Unsuccessful -> fakeprint "Something went wrong. No account has been created"
				| _ -> createloginresp; ()
			| _ -> resp; ()

	val changeUserPassword: authp:prin -> unit

	let changeUserPassword authp =
		let name = userid in
		let pw = password in
		let newpw = newPassword in
		let req = ChangePassword name pw newpw in
		let _ = SendMessage authp req in
			let resp = ReceiveMessage authp in
			match resp with
			| StatusMessage(status) ->
					match status with
					| Successful -> fakeprint "You have change your password"
					| Unsuccessful -> fakeprint "Something went wrong. You have not changed your password"
			| _ -> resp; ()

	val changeUserUserId: authp:prin -> unit

	let changeUserUserId authp =
		let name = userid in
		let pw = password in
		let newid = newUserId in
		let req = ChangeUserId name newid pw in
		let _ = SendMessage authp req in
		let resp = ReceiveMessage authp in
			match resp with
			| StatusMessage(status) ->
					match status with
					| Successful -> fakeprint "You have change your userid"
					| Unsuccessful -> fakeprint "Something went wrong. You have not changed your userid"
			| _ -> resp; ()

	val identityrevoke: authp:prin -> unit

	let identityrevoke authp =
		let name = userid in
		let pw = password in
		let idp = idpToRevoke in
		let req = UserRevokeIdp name pw idp in
		let _ = SendMessage authp req in
		let resp = ReceiveMessage authp in
			match resp with
			| StatusMessage(status) ->
					match status with
					| Successful -> fakeprint "You have revoked the identityprovider"
					| Unsuccessful -> fakeprint "Something went wrong. You have not revoked the identityprovider"
			| _ -> resp; ()

	val addNfact: authp:prin -> unit

	let addNfact authp =
		let name = userid in
		let pw = password in
		let nfact = nfactToAdd in
		let req = AddNfactor name pw nfact in
		let _ = SendMessage authp req in
		let resp = ReceiveMessage authp in
			match resp with
			| StatusMessage(status) ->
					match status with
					| Successful -> fakeprint "You have added this authentication method"
					| Unsuccessful -> fakeprint "Something went wrong. You have not added this authentication method"
			| _ -> resp; ()

	val removeNfact: authp:prin -> unit

	let removeNfact authp =
		let name = userid in
		let pw = password in
		let nfact = nfactToRemove in
		let req = RemoveNfactor name pw nfact in
		let _ = SendMessage authp req in
		let resp = ReceiveMessage authp in
			match resp with
			| StatusMessage(status) ->
					match status with
					| Successful -> fakeprint "You have removed this authentication method"
					| Unsuccessful -> fakeprint "Something went wrong. You have not removed this authentication method"
			| _ -> resp; ()
\end{lstlisting}

This part of the Browser module is pretty straightforward. It specifies a lot of functions that will create the user's account and update the account by the user's wish. The nonce created when a user creates an account is used to relate the creation of an account to a user.

\section{Introducing adversaries}
\label{sect:introadversary}
In the previous section we have been focused on implementation of the protocol according to the specification. This section will introduce adversaries into the protocol verification however we have not managed in this project to incorporate dedicated adversaries. Jacob introduced adversaries in his protocol verification through an abstract program and a main function to execute a protocol run. We have adopted this way of introducing an adversary and applied it to the OpenNemID protocol as shown in Listing \ref{list:adversary}. The difference between our way of introducing an adversary and Jacob's is that ours also have the authentication provider. The abstract \emph{attacker} function is a parameter to the \emph{main} function. This means that it is able to use any function defined in the modules. However it will not be able to call any assume command, i.e. every assertion in the service provider, identity provider and authentication provider will succeed.

\begin{lstlisting}[style=fstar, caption={Main module for introducing adversaries}, label={list:adversary}]
	module Main

	open SamlProtocol
	open Crypto
	open Serviceprovider
	open Identityprovider
	open Authenticationprovider

	val Fork: list (unit -> unit) -> unit	

	let main attacker =	
		Fork [	attacker;
			(fun () -> serviceprovider "serviceprovider.org" "browser" "identityprovider.org");
			(fun () -> identityprovider "identityprovider.org" "browser" "authenticationprovider.org");
			(fun () -> authenticationprovider "authenticationprovider.org" "identityprovider.org" "browser")]
\end{lstlisting}

It would be possible to model and mitigate known attacks on the protocol like \emph{Man In the Middle}, \emph{authentication replay} and \emph{session hijacking} by modeling a browser as part of the protocol model. We have modeled the browser but we have not modeled the aforementioned attacks due to time constraints.

\section{State of the implementation}
We have implemented the identity provider, service provider and authentication provider in the OpenNemID protocol and defined their abstract implementation but they are all missing session handling. Furthermore the implementations of the cryptographic elements and networking are only abstract signatures at the moment. If time had allowed it we could have incorporated the crypto and networking experiments done by Jacob into the model which have been attached in appendix \ref{chap:jacobcode}. As the previous section explained we have not modeled dedicated adversaries as a part of the present implementation either.


\chapter{Evaluation}
This chapter is an evaluation of the entire project. It will describe what has been accomplished during the project and what the work in this project can contribute with. It will also outline the most sensible areas to research further and discuss what related work have been done.

\section{Project evaluation}
In this report we have outlined the work of this project. The primary work in this project has been the specification of the OpenNemID protocol including a service provider, identity provider and authentication provider written in F*.
\par
Working with a research language like F* can be a difficult challenge. However working with F* has not been quite as difficult as expected. This is due to the fact that we have extended the work done by Jacob and the F*-project is well documented with a tutorial. This means that we could always use Jacob's work as a reference and the compiler was easy to set up. We both have a little experience with ML and the functional language F\# which F* is based on - these facts also helped us during the development of this project. Furthermore we both also have a strong background in C\# and .NET.
\par
The model of OpenNemID we have presented can be evaluated against common software development and software architecture principles. What should be noted as interesting is not the design of modules but the kind of style a language like F* imposes on the developer. F* enforces the principle of programming to an interface. F* takes the principle further to \emph{design by contract} known from other languages. Functional languages with immutability as default makes it easier for developers to design components that holds no state. This makes the scalability of a system across multiple processors or computers a lot easier.

\section{Related work}
We have extended the work done by Jacob H{\o}jgaard \cite{jacob} in his masters thesis \emph{Securing Single Sign-On System With Executable Models}. His work has had a huge impact on this project as we have stated throughout the report. The impact has been both in the understanding of the language F* and designing and specifying the OpenNemID protocol. In the masters thesis \emph{Using static analysis to validate SAML Protocols} written by Hansen and Skriver \cite{HansenSkriver} they analyze and formalize the SAML login protocol. Their analysis goes towards the older version 1.1 SAML protocol. In their analysis they recommend mandating of HTTPS network transport. This has been incorporated in the OIOSAML specification and Jacob had included it in his implementation.

\section{Threats to validity}
When working in the area of security protocols there will be a lot of threats to validity. Therefore it is important to scrutinize the work of this report.
\par
As stated earlier we both have a little experience with the functional programming language F\# which F* is based on. However since we are no experts in F\# and have worked mostly with object-oriented languages there is a chance that the capabilities of F* has not been fully utilized. Furthermore we have not worked with any formal specification tools before commencing this project.
\par
It is also important to remember that the F* compiler is still an $\alpha$-release. Microsoft Research has used it to verify 20.000 lines of code \cite{fstar-msr} but the results should still be treated with some degree of caution. Still the concepts F* are based on, are derived from the work in the previous projects, F7 and Fine. In these projects the concepts have been investigated thoroughly.
\par
Lastly it is worth noting we have only touched the subject of modeling adversaries very briefly. This leaves room for uncertainty and therefore would be a natural course to take for further research.

\section{Further research}
As we have mentioned the modeling of adversaries is the natural path to take because this is required to make a more robust framework for protocol verification. In Section \ref{sect:introadversary} we described that we have modeled a browser but we have not modeled adversaries as part of the browser. This could be a way to continue the research. We mentioned briefly that F* could be compiled to JavaScript. The compilation of F* to JavaScript is interesting because NemID uses a Java applet which forces all the user to install a Java browser plug-in. Given the facts that, as stated in Chapter \ref{chap:intro}, Java is one of the most frequently exploited pieces of software, and also that DanID is working on a version of NemID that uses JavaScript instead of Java, it could indicate that F*'s compilation to JavaScript capability would be a way to go. This means that a specification in F* could be compiled to JavaScript and used on the web and thereby eliminate the large security risk involved with using the Java applet. Further research could also be into the server side of the authentication provider. As we have specified the authentication provider the next step would be to actually creating the server side of it so it could be an executable protocol on the web.
\par
Our design of OpenNemID included security profiles. Due to time constraints this has not been formally specified in the current specification of OpenNemID in F*. Continuing the research could be done by extending the protocol specification to support the functionality of security profiles.

\section{Conclusion}
In this report we have shown how the use of the programming language F* for implementing security protocols can help proving the security properties of the protocol.
\par
In this project we have extended the work of Jacob H{\o}jgaard whom has used the Danish governmental Single Sign-On federation - Nemlog-in as an example. Nemlog-in is a protocol based on the SAML standard for exchanging security tokens. In the Nemlog-in protocol the authentication part has been done by DanID. This project has extended and modified the protocol specification done by Jacob to specify the authentication part as well. A protocol we refer to as OpenNemID. OpenNemID has been described and outlined including the registration of users and logging in of users.
\par
In this report we have formally specified key parts of the OpenNemID protocol using the F* programming language to the extent possible and used it to secure key properties such as signing of the messages exchanged over the network.
\par
Since there has only been formally specified key security properties we have described a way forward for securing other properties. We have suggested the use of F* to model known attacks as part of the protocol test suite.
\par
In conclusion a functional language such as F* can be used to create an executable model of a security protocol. This ensures the security features mandated by the protocol.

\begin{thebibliography}{9}

\bibitem{AppliedInfoS}
  David Basin, Patrick Schaller, Michael Schl{\"a}pfer:
  \emph{Applied Information Security - A Hands-on Approach}.
  Springer, Berlin Heidelberg,
  2011.

\bibitem{dolev-yao}
 Danny Dolev, Andrew C. Yao:
 \emph{On the security of public key protocols}.
 Technical report, Stanford, CA, USA
 1981.

\bibitem{HansenSkriver}
  Steffen M. Hansen, Jakob Skriver:
  \emph{Using Static Analysis to Validate SAML Protocols}.
  \\Masters thesis, Technical University of Denmark,
  2004.

\bibitem{jacob}
  Jakob H{\o}jgaard:
  \emph{Securing Single Sign-On System With Executable Models}.
  Masters thesis, IT University of Copenhagen,
  2013.

\bibitem{kerckhoffs}
 Auguste Kerckhoffs:
 \emph{La cryptographie militaire.}
 Journal des Sciences Militaires, IX:5–38, 161–191, 1883

\bibitem{wayf}
 The WAYF secretariat:
 \emph{Trusted third party based ID federation, lowering the bar for connecting and enhancing privacy}.
 Explanation of WAYF, 2009.

\bibitem{csproto}
 CSProto:
 \emph{Tool for analyzing contract signing protocols}
 \url{http://www.infsec.uni-trier.de/publications/paper/KaehlerKuestersWilke-TOCL-2010.pdf}

\bibitem{dh-proverif}
 DH-ProVerif:
 \emph{Tool for analyzing protocol with Diffie-Hellman exponentiation}.
 \url{http://www.infsec.uni-trier.de/publications/paper/KuestersTruderung-CSF-2009.pdf}

\bibitem{digst}
 Digitaliseringsstyrrelsen:
 \emph{Den digitale vej til fremtiden velf{\ae}rd - Den f{\ae}llesoffentlige digitaliseringsstrategi 2011-2015}.
 \url{http://www.digst.dk/Home/Digitaliseringsstrategi/~/media/Files/Digitaliseringsstrategi/Digitale_vej_til_fremtidens_velf\%C3\%A6rd.ashx}

\bibitem{ftspeech}
 Dr. Joseph Roland Kiniry:
 \emph{Parliamentary Statement for Bill L-132}
 \url{http://www.ft.dk/samling/20121/almdel/kou/bilag/70/1225808.pdf}

\bibitem{jscert}
 JSCert:
 \emph{Certified JavaScript}.
 \url{http://jscert.org/index.html}

\bibitem{kaspersky}
 Kaspersky:
 \emph{Oracle Java surpasses Adobe Reader as the most frequently exploited software}
 \url{http://www.kaspersky.com/about/news/virus/2012/Oracle_Java_surpasses_Adobe_Reader_as_the_most_frequently_exploited_software}

\bibitem{fstar-msr}
 Microsoft Research:
 \emph{F*: A Verifying ML Compiler for Distributed Programming}.
 \url{http://research.microsoft.com/en-us/projects/fstar/}

\bibitem{rise4fun}
 Microsoft Research:
 \emph{F* guide}
 \url{http://rise4fun.com/FStar/tutorial/guide}

\bibitem{nacl}
 NaCl:
 \emph{Networking and Cryptography library}.
 \url{http://nacl.cr.yp.to}

\bibitem{omnemidsikkerhed}
 NemID:
 \emph{Om NemID - Sikkerhed}
 \url{https://www.nemid.nu/dk-da/om_nemid/sikkerhed/}

\bibitem{nemidcontract}
 Nets DanID:
 \emph{Forretningsbetingelser MOCES DanID april 2012}.
 \url{https://www.nets-danid.dk/produkter/nemid_medarbejdersignatur/vilkaar/forretningsbetingelser_nemid_administrator/Forretningsbetingelser_MOCES_DanID_april_2012.pdf}

\bibitem{nemid-guide}
 Nets-Danid:
 \emph{NemID guide}
 \url{https://www.nets-danid.dk/produkter/for_tjenesteudbydere/nemid_tjenesteudbyder/nemid_tjenesteudbyder_support/tjenesteudbyderpakken/}

\bibitem{openid}
 OpenID:
 \emph{OpenID Foundation website}
 \url{http://openid.net/}

\bibitem{proverif}
 ProVerif:
 \emph{Cryptographic protocol verifier in the formal model}.
 \url{http://prosecco.gforge.inria.fr/personal/bblanche/proverif/}

\bibitem{rfc6238}
 RFC 6238:
 \emph{TOTP: Time-Based One-Time Password Algorithm}
 \url{http://tools.ietf.org/html/rfc6238}

\bibitem{maffeis}
 Sergio Maffeis:
 \emph{An expert in computer security}.
 Various publications on web security, security protocols and so on.
 \url{http://www.doc.ic.ac.uk/~maffeis/}

\bibitem{sodium}
 Sodium:
 \emph{A new cross-compilable Cryptography library}.
 A variation of the NaCl library.
 \url{http://labs.umbrella.com/2013/03/06/announcing-sodium-a-new-cryptographic-library/}

\bibitem{webcrypto}
 W3.org: 
 \emph{Web Cryptography API}.
 \url{http://www.w3.org/TR/WebCryptoAPI/}

\bibitem{xor-proverif}
 XOR-ProVerif:
 \emph{Tool for analyzing protocols with XOR}.
 \url{http://www.infsec.uni-trier.de/publications/paper/KuestersTruderung-CCS-2008.pdf}

\bibitem{yubico}
 Yubico:
 \emph{Two-factor authentication with the YubiKey}
 \url{http://www.yubico.com/}

\end{thebibliography}

\appendix
\chapter{SAML Assertion and Messages}
\begin{lstlisting}[style=cxml, caption={[Sample SAML AuthnRequest message]Sample SAML AuthnRequest message \cite{jacob}.}]
	<samlp:AuthnRequest ID="id84be1b160a0b44d893402f993f080679" Version="2.0"IssueInstant="2012-10-23T18:36:14.5304032Z" Destination="https://login.idp.dk" IsPassive="false"xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol">
		<Issuer xmlns="urn:oasis:names:tc:SAML:2.0:assertion">https://saml.serviceprovider.dk</Issuer>
		<Conditions xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
			<AudienceRestriction>
				<Audience>https://saml.serviceprovider.dk</Audience>
			</AudienceRestriction>
		</Conditions>
	</samlp:AuthnRequest>
\end{lstlisting}

\begin{lstlisting}[style=cxml, caption={[Sample SAML Response message without the content of the Assertion]Sample SAML Response message without the content of the Assertion \cite{jacob}.}]
	<samlp:Response ID="_e0ef82f8-f8d9-4 bcc-a4da-894 a165a04c9" Version="2.0"IssueInstant="2012-10-23T18:36:37.997Z" Destination="https://login.serviceprovider.dk" Consent="urn:oasis:names:tc:SAML:2.0:consent:unspecified" InResponseTo="id84be1b160a0b44d893402f993f080679" xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol">
		<Issuer xmlns="urn:oasis:names:tc:SAML:2.0:assertion">https://saml.idp.dk</Issuer>
		<samlp:Status>
			<samlp:StatusCode Value="urn:oasis:names:tc:SAML:2.0:status:Success"/>
		</samlp:Status>
		<Assertion ID="_b3e42065-401b-4 fe6-954b-2 f485828e68b" IssueInstant="2012-10-23T18:36:37.997Z"Version="2.0" xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
			...
		</Assertion>
	</samlp:Response>
\end{lstlisting}

\begin{lstlisting}[style=cxml, caption={[Sample SAML Assertion]Sample SAML Assertion \cite{jacob}.}]
	<Assertion ID="_b3e42065-401b-4 fe6-954b-2 f485828e68b" IssueInstant="2012-10-23T18:36:37.997Z"Version="2.0" xmlns="urn:oasis:names:tc:SAML:2.0:assertion">
		<Issuer>https://saml.idp.dk</Issuer>
		<ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
			...
		</ds:Signature>
		<Subject>
			<NameID Format="urn:oasis:names:tc:SAML:1.1:nameid-format:X509SubjectName">The Subject</NameID>
			<SubjectConfirmation Method="urn:oasis:names:tc:SAML:2.0:cm:bearer">
				<SubjectConfirmationData InResponseTo="id84be1b160a0b44d893402f993f080679"NotOnOrAfter="-10-23T18:41:37.997Z"Recipient="https://saml.serviceprovider.dk"/>
			</SubjectConfirmation>
		</Subject>
		<Conditions NotBefore="2012-10-23T18:36:37.997Z" NotOnOrAfter="2012-10-23T19:36:37.997Z">
			<AudienceRestriction>
				<Audience>https://saml.serviceprovider.dk</Audience>
			</AudienceRestriction>
		</Conditions>
		<AttributeStatement>
			<Attribute Name="urn:oid:2.5.4.3"NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic">
				<AttributeValue>Frode Bo</AttributeValue>
			</Attribute>
			<Attribute Name="urn:oid:0.9.2342.19200300.100.1.3" NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:basic">
				<AttributeValue>fbh@mail.dk</AttributeValue>
			</Attribute>
		</AttributeStatement>
		<AuthnStatement AuthnInstant="2012-10-23T18:36:36.622Z" SessionIndex="_b3e42065-401b-4 fe6-954b-2 f485828e68b">
			<AuthnContext>
				<AuthnContextClassRef>urn:oasis:names:tc:SAML:2.0:ac:classes:X509</AuthnContextClassRef>
			</AuthnContext>
		</AuthnStatement>
	</Assertion>
\end{lstlisting}

\chapter{Source code examples}
\label{chap:jacobcode}
\section{Interop declarations}
\begin{lstlisting}[style=fstar, caption={[Example of how to interop with .NET]Example of how to interop with .NET \cite{jacob}.}]
	module Interop

	open Protocol
	
	(*Crypto functions*)
	extern reference Crypto {language="F#"; dll="RuntimeExtention"; namespace=""; classname="Crypto"}
	
	extern Crypto val KeyGenExt: p:prin -> (pubkey p * privkey p)
	
	(*Saml functions*)
	extern reference Saml {language="F#"; dll="RuntimeExtention"; namespace=""; classname="Saml"}
	
	extern Saml val CreateAuthnRequest: issuer:prin -> destination:prin -> samlmessage
	extern Saml val CreateChallenge: prin -> nonce
	extern Saml val CreateSamlAssertion: user:string -> issuer:prin -> destination:prin -> assertion
	extern Saml val CreateSamlResponse: issuer:prin -> destination:prin -> assertion -> samlmessage
	extern Saml val CreateSamlFailedResponse: issuer:prin -> destination:prin -> SamlStatus -> samlmessage
	
	extern reference Network {language="F#";  dll="RuntimeExtention"; namespace=""; classname="Network"}
	extern Network val SendX: prin -> message -> bool
	extern Network val RecieveX: prin -> message
\end{lstlisting}
\clearpage
\section{Using .NET functions}
\begin{lstlisting}[style=fstar, caption={[Example of how use types from .NET]Example of how use types from .NET \cite{jacob}.}]
	module X

	open Protocol
	open Interop
	
	val GenKeys: prin -> string
	let GenKeys principal = 
		println "starting keygen";
		let (privk, pubk) = KeyGenExt principal in
		print_int 2;
		"super"
	
	val GetReq: prin -> prin -> samlmessage
	let GetReq sp idp = 
		CreateAuthnRequest sp idp
		
	val GetSamlMessages: prin -> prin -> string
	let GetSamlMessages sp idp = 
		print_string "Getting AuthReq\n";
		let req = CreateAuthnRequest sp idp in
		print_string req;
		print_string "\nGetting Assertion\n";
		let assertion = CreateSamlAssertion "me" idp sp in
		print_string assertion;
		print_string "\nGetting Response\n";
		let response = CreateSamlResponse idp sp assertion in
		print_string response;
		"Done"
	
	val CreateAndSend: prin -> prin ->unit
	let CreateAndSend sp idp =
		let authReq = CreateAuthnRequest sp idp in
		let req = SamlProtocolMessage sp authReq "sig" in
		let status = SendX sp req in
		match status with
		| true -> print_string "great!";()
		| _ -> print_string "failure!";()
	
	val CreateSendAndRecieve: prin -> prin ->unit
	let CreateSendAndRecieve sp idp =
		let authReq = CreateAuthnRequest sp idp in
		let req = SamlProtocolMessage sp authReq "sig" in
		let status = SendX sp req in
		match status with
		| true -> print_string "great!";
			let msg = RecieveX sp in
			match msg with
			| HttpGet (url) -> 
				print_string url;()
		| _ -> print_string "failure!";()
\end{lstlisting}
\clearpage
\section{Crypto wrapper implemented in F\#}
\begin{lstlisting}[style=fstar, caption={[Example of implementation of crypto functions in F\#]Example of implementation of crypto functions in F\# \cite{jacob}.}]
	module Crypto

	open System.Security.Cryptography
	open System.Text
	open System
	open System.IO
	
	let GetEncoder = new ASCIIEncoding()
	let GetHashProvicer = new SHA1CryptoServiceProvider()
	let GetCryptoProvider = new RSACryptoServiceProvider()
	
	let WriteKeyToFile (filename:string) (key:string) = 
		let fn = filename.Replace("://", "-")
		let file = File.CreateText(fn)
		file.Write key |>  file.Close
	
	let KeyGenExt prin : Prims.DepTuple<Protocol.pubkey,Protocol.privkey> = 
		let cspParams = new CspParameters()
		cspParams.ProviderType <- 1
		cspParams.Flags <- CspProviderFlags.UseArchivableKey
		cspParams.KeyNumber <- int KeyNumber.Exchange
		let rsaProvicer = GetCryptoProvider
	
		(* Export Public Key *)
		let pubkey = Protocol.pubkey(0,rsaProvicer.ToXmlString false)
	
		(* Export private key *)
		let privkey = Protocol.privkey(0,rsaProvicer.ToXmlString true)
		new Prims.DconDepTuple<Protocol.pubkey,Protocol.privkey>(pubkey, privkey) :> Prims.DepTuple<Protocol.pubkey,Protocol.privkey>
	
	let SignMessage (prin:string) (key:string) (msg:string) : string = 
		let ByteConverter = GetEncoder
		let msgData = ByteConverter.GetBytes(msg)
		let alg = GetCryptoProvider
		alg.FromXmlString key
		let signedData = alg.SignData(msgData, GetHashProvicer)
		Convert.ToBase64String(signedData)
	
	let ValidateMessage (prin:string) (key:string) (msg:string) (signature:string) : bool = 
		let ByteConverter = GetEncoder
		let dataToVerify = ByteConverter.GetBytes msg
		let sign = Convert.FromBase64String signature
		let alg = GetCryptoProvider
		alg.FromXmlString key
		alg.VerifyData(dataToVerify, GetHashProvicer, sign)
\end{lstlisting}
\clearpage
\section{SAML wrapper implemented in F\#}
\begin{lstlisting}[style=fstar, caption={[Example of implementation of SAML functions in F\#]Example of implementation of SAML functions in F\# \cite{jacob}.}]
	module Saml

	open System
	open System.Security.Cryptography
	
	let CreateChallenge prin = 
		let provider = new RNGCryptoServiceProvider()
		let randBytes = Array.create 10 (byte 0)
		let _ = provider.GetNonZeroBytes randBytes
		BitConverter.ToString (randBytes)
	
	let CreateAuthnRequest sp idp = 
		let authnReq = new dk.nita.saml20.Saml20AuthnRequest()
		authnReq.Destination <- idp
		authnReq.Issuer <- sp
		let doc = authnReq.GetXml()
		doc.InnerXml
	
	let CreateSamlAssertion user issuer destination = 
		let assertion = new dk.nita.saml20.Schema.Core.Assertion()
		assertion.Issuer <- issuer
		"assertion"
	
	let CreateSamlResponse user issuer destination status =
		let response = new dk.nita.saml20.Schema.Protocol.Response()
		response.Issuer <- issuer
		response.IssueInstant <- Nullable(DateTime.UtcNow)
		response.Destination <- destination
		response
\end{lstlisting}
\clearpage
\section{Network wrapper implemented in F\#}
\begin{lstlisting}[style=fstar, caption={[Example of implementation of network functions in F\#]Example of implementation of network functions in F\# \cite{jacob}.}]
	module Network

	open System
	open System.Net
	open System.Text
	
	let listener = new HttpListener()
	
	let GetMsg (msg:Protocol.message) = 
		match msg with
		| :? Protocol.SamlProtocolMessage -> (msg :?> Protocol.SamlProtocolMessage).field_2
		| _ -> "<html><head><title>Server</title></head><body><h1>Message from: \%s not valid</h1></body></html>"
	
	let StartListen  = 
		listener.Prefixes.Add("http://localhost:8080/")
		listener.Start()
		printfn "listening...."
	
	let GetContext = listener.GetContext()
	
	let SendX (prin:string) (msg:Protocol.message) = 
		let resp = GetContext.Response
		let cookie = new Cookie("AuthnTicket", "12 02 002 020 22")
		resp.AppendCookie(cookie)
		let respmsg = GetMsg msg
		let buffer = System.Text.Encoding.UTF8.GetBytes(respmsg)
		resp.ContentLength64 <- int64 buffer.Length
		let output = resp.OutputStream;
		output.Write(buffer,0,buffer.Length)
		output.Close();
		true
	
	let RecieveX (prin:string) : (Protocol.message) =
		let req = GetContext.Request
		match prin with
		| "sp" ->  Protocol.HttpGet ("Request to sp: " + req.RawUrl) :> Protocol.message
		| "idp" -> Protocol.HttpGet "This is a idp reply" :> Protocol.message
		| "browser" -> Protocol.HttpGet "This is a browserreply" :> Protocol.message
		| _ -> Protocol.Failed 400 :> Protocol.message
\end{lstlisting}
\end{document}